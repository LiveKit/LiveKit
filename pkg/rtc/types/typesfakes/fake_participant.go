// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/livekit/livekit-server/pkg/routing"
	"github.com/livekit/livekit-server/pkg/rtc/types"
	"github.com/livekit/livekit-server/proto/livekit"
	"github.com/pion/rtcp"
	webrtc "github.com/pion/webrtc/v3"
)

type FakeParticipant struct {
	AddICECandidateStub        func(webrtc.ICECandidateInit, livekit.SignalTarget) error
	addICECandidateMutex       sync.RWMutex
	addICECandidateArgsForCall []struct {
		arg1 webrtc.ICECandidateInit
		arg2 livekit.SignalTarget
	}
	addICECandidateReturns struct {
		result1 error
	}
	addICECandidateReturnsOnCall map[int]struct {
		result1 error
	}
	AddSubscribedTrackStub        func(string, types.SubscribedTrack)
	addSubscribedTrackMutex       sync.RWMutex
	addSubscribedTrackArgsForCall []struct {
		arg1 string
		arg2 types.SubscribedTrack
	}
	AddSubscriberStub        func(types.Participant) error
	addSubscriberMutex       sync.RWMutex
	addSubscriberArgsForCall []struct {
		arg1 types.Participant
	}
	addSubscriberReturns struct {
		result1 error
	}
	addSubscriberReturnsOnCall map[int]struct {
		result1 error
	}
	AddTrackStub        func(string, string, livekit.TrackType)
	addTrackMutex       sync.RWMutex
	addTrackArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 livekit.TrackType
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	GetAudioLevelStub        func() (uint8, bool)
	getAudioLevelMutex       sync.RWMutex
	getAudioLevelArgsForCall []struct {
	}
	getAudioLevelReturns struct {
		result1 uint8
		result2 bool
	}
	getAudioLevelReturnsOnCall map[int]struct {
		result1 uint8
		result2 bool
	}
	GetResponseSinkStub        func() routing.MessageSink
	getResponseSinkMutex       sync.RWMutex
	getResponseSinkArgsForCall []struct {
	}
	getResponseSinkReturns struct {
		result1 routing.MessageSink
	}
	getResponseSinkReturnsOnCall map[int]struct {
		result1 routing.MessageSink
	}
	HandleAnswerStub        func(webrtc.SessionDescription) error
	handleAnswerMutex       sync.RWMutex
	handleAnswerArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	handleAnswerReturns struct {
		result1 error
	}
	handleAnswerReturnsOnCall map[int]struct {
		result1 error
	}
	HandleOfferStub        func(webrtc.SessionDescription) (webrtc.SessionDescription, error)
	handleOfferMutex       sync.RWMutex
	handleOfferArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	handleOfferReturns struct {
		result1 webrtc.SessionDescription
		result2 error
	}
	handleOfferReturnsOnCall map[int]struct {
		result1 webrtc.SessionDescription
		result2 error
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	IdentityStub        func() string
	identityMutex       sync.RWMutex
	identityArgsForCall []struct {
	}
	identityReturns struct {
		result1 string
	}
	identityReturnsOnCall map[int]struct {
		result1 string
	}
	IsReadyStub        func() bool
	isReadyMutex       sync.RWMutex
	isReadyArgsForCall []struct {
	}
	isReadyReturns struct {
		result1 bool
	}
	isReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	OnCloseStub        func(func(types.Participant))
	onCloseMutex       sync.RWMutex
	onCloseArgsForCall []struct {
		arg1 func(types.Participant)
	}
	OnStateChangeStub        func(func(p types.Participant, oldState livekit.ParticipantInfo_State))
	onStateChangeMutex       sync.RWMutex
	onStateChangeArgsForCall []struct {
		arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)
	}
	OnTrackPublishedStub        func(func(types.Participant, types.PublishedTrack))
	onTrackPublishedMutex       sync.RWMutex
	onTrackPublishedArgsForCall []struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}
	OnTrackUpdatedStub        func(func(types.Participant, types.PublishedTrack))
	onTrackUpdatedMutex       sync.RWMutex
	onTrackUpdatedArgsForCall []struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}
	RTCPChanStub        func() chan []rtcp.Packet
	rTCPChanMutex       sync.RWMutex
	rTCPChanArgsForCall []struct {
	}
	rTCPChanReturns struct {
		result1 chan []rtcp.Packet
	}
	rTCPChanReturnsOnCall map[int]struct {
		result1 chan []rtcp.Packet
	}
	RemoveSubscribedTrackStub        func(string, types.SubscribedTrack)
	removeSubscribedTrackMutex       sync.RWMutex
	removeSubscribedTrackArgsForCall []struct {
		arg1 string
		arg2 types.SubscribedTrack
	}
	RemoveSubscriberStub        func(string)
	removeSubscriberMutex       sync.RWMutex
	removeSubscriberArgsForCall []struct {
		arg1 string
	}
	SendActiveSpeakersStub        func([]*livekit.SpeakerInfo) error
	sendActiveSpeakersMutex       sync.RWMutex
	sendActiveSpeakersArgsForCall []struct {
		arg1 []*livekit.SpeakerInfo
	}
	sendActiveSpeakersReturns struct {
		result1 error
	}
	sendActiveSpeakersReturnsOnCall map[int]struct {
		result1 error
	}
	SendJoinResponseStub        func(*livekit.Room, []types.Participant) error
	sendJoinResponseMutex       sync.RWMutex
	sendJoinResponseArgsForCall []struct {
		arg1 *livekit.Room
		arg2 []types.Participant
	}
	sendJoinResponseReturns struct {
		result1 error
	}
	sendJoinResponseReturnsOnCall map[int]struct {
		result1 error
	}
	SendParticipantUpdateStub        func([]*livekit.ParticipantInfo) error
	sendParticipantUpdateMutex       sync.RWMutex
	sendParticipantUpdateArgsForCall []struct {
		arg1 []*livekit.ParticipantInfo
	}
	sendParticipantUpdateReturns struct {
		result1 error
	}
	sendParticipantUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SetMetadataStub        func(map[string]interface{}) error
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		arg1 map[string]interface{}
	}
	setMetadataReturns struct {
		result1 error
	}
	setMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	SetResponseSinkStub        func(routing.MessageSink)
	setResponseSinkMutex       sync.RWMutex
	setResponseSinkArgsForCall []struct {
		arg1 routing.MessageSink
	}
	SetTrackMutedStub        func(string, bool)
	setTrackMutedMutex       sync.RWMutex
	setTrackMutedArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	StartStub        func()
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	StateStub        func() livekit.ParticipantInfo_State
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 livekit.ParticipantInfo_State
	}
	stateReturnsOnCall map[int]struct {
		result1 livekit.ParticipantInfo_State
	}
	SubscriberMediaEngineStub        func() *webrtc.MediaEngine
	subscriberMediaEngineMutex       sync.RWMutex
	subscriberMediaEngineArgsForCall []struct {
	}
	subscriberMediaEngineReturns struct {
		result1 *webrtc.MediaEngine
	}
	subscriberMediaEngineReturnsOnCall map[int]struct {
		result1 *webrtc.MediaEngine
	}
	SubscriberPCStub        func() *webrtc.PeerConnection
	subscriberPCMutex       sync.RWMutex
	subscriberPCArgsForCall []struct {
	}
	subscriberPCReturns struct {
		result1 *webrtc.PeerConnection
	}
	subscriberPCReturnsOnCall map[int]struct {
		result1 *webrtc.PeerConnection
	}
	ToProtoStub        func() *livekit.ParticipantInfo
	toProtoMutex       sync.RWMutex
	toProtoArgsForCall []struct {
	}
	toProtoReturns struct {
		result1 *livekit.ParticipantInfo
	}
	toProtoReturnsOnCall map[int]struct {
		result1 *livekit.ParticipantInfo
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeParticipant) AddICECandidate(arg1 webrtc.ICECandidateInit, arg2 livekit.SignalTarget) error {
	fake.addICECandidateMutex.Lock()
	ret, specificReturn := fake.addICECandidateReturnsOnCall[len(fake.addICECandidateArgsForCall)]
	fake.addICECandidateArgsForCall = append(fake.addICECandidateArgsForCall, struct {
		arg1 webrtc.ICECandidateInit
		arg2 livekit.SignalTarget
	}{arg1, arg2})
	stub := fake.AddICECandidateStub
	fakeReturns := fake.addICECandidateReturns
	fake.recordInvocation("AddICECandidate", []interface{}{arg1, arg2})
	fake.addICECandidateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) AddICECandidateCallCount() int {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	return len(fake.addICECandidateArgsForCall)
}

func (fake *FakeParticipant) AddICECandidateCalls(stub func(webrtc.ICECandidateInit, livekit.SignalTarget) error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = stub
}

func (fake *FakeParticipant) AddICECandidateArgsForCall(i int) (webrtc.ICECandidateInit, livekit.SignalTarget) {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	argsForCall := fake.addICECandidateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) AddICECandidateReturns(result1 error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = nil
	fake.addICECandidateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddICECandidateReturnsOnCall(i int, result1 error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = nil
	if fake.addICECandidateReturnsOnCall == nil {
		fake.addICECandidateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addICECandidateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddSubscribedTrack(arg1 string, arg2 types.SubscribedTrack) {
	fake.addSubscribedTrackMutex.Lock()
	fake.addSubscribedTrackArgsForCall = append(fake.addSubscribedTrackArgsForCall, struct {
		arg1 string
		arg2 types.SubscribedTrack
	}{arg1, arg2})
	stub := fake.AddSubscribedTrackStub
	fake.recordInvocation("AddSubscribedTrack", []interface{}{arg1, arg2})
	fake.addSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.AddSubscribedTrackStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) AddSubscribedTrackCallCount() int {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	return len(fake.addSubscribedTrackArgsForCall)
}

func (fake *FakeParticipant) AddSubscribedTrackCalls(stub func(string, types.SubscribedTrack)) {
	fake.addSubscribedTrackMutex.Lock()
	defer fake.addSubscribedTrackMutex.Unlock()
	fake.AddSubscribedTrackStub = stub
}

func (fake *FakeParticipant) AddSubscribedTrackArgsForCall(i int) (string, types.SubscribedTrack) {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	argsForCall := fake.addSubscribedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) AddSubscriber(arg1 types.Participant) error {
	fake.addSubscriberMutex.Lock()
	ret, specificReturn := fake.addSubscriberReturnsOnCall[len(fake.addSubscriberArgsForCall)]
	fake.addSubscriberArgsForCall = append(fake.addSubscriberArgsForCall, struct {
		arg1 types.Participant
	}{arg1})
	stub := fake.AddSubscriberStub
	fakeReturns := fake.addSubscriberReturns
	fake.recordInvocation("AddSubscriber", []interface{}{arg1})
	fake.addSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) AddSubscriberCallCount() int {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	return len(fake.addSubscriberArgsForCall)
}

func (fake *FakeParticipant) AddSubscriberCalls(stub func(types.Participant) error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = stub
}

func (fake *FakeParticipant) AddSubscriberArgsForCall(i int) types.Participant {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	argsForCall := fake.addSubscriberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) AddSubscriberReturns(result1 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	fake.addSubscriberReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddSubscriberReturnsOnCall(i int, result1 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	if fake.addSubscriberReturnsOnCall == nil {
		fake.addSubscriberReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSubscriberReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddTrack(arg1 string, arg2 string, arg3 livekit.TrackType) {
	fake.addTrackMutex.Lock()
	fake.addTrackArgsForCall = append(fake.addTrackArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 livekit.TrackType
	}{arg1, arg2, arg3})
	stub := fake.AddTrackStub
	fake.recordInvocation("AddTrack", []interface{}{arg1, arg2, arg3})
	fake.addTrackMutex.Unlock()
	if stub != nil {
		fake.AddTrackStub(arg1, arg2, arg3)
	}
}

func (fake *FakeParticipant) AddTrackCallCount() int {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	return len(fake.addTrackArgsForCall)
}

func (fake *FakeParticipant) AddTrackCalls(stub func(string, string, livekit.TrackType)) {
	fake.addTrackMutex.Lock()
	defer fake.addTrackMutex.Unlock()
	fake.AddTrackStub = stub
}

func (fake *FakeParticipant) AddTrackArgsForCall(i int) (string, string, livekit.TrackType) {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	argsForCall := fake.addTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeParticipant) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeParticipant) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeParticipant) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) GetAudioLevel() (uint8, bool) {
	fake.getAudioLevelMutex.Lock()
	ret, specificReturn := fake.getAudioLevelReturnsOnCall[len(fake.getAudioLevelArgsForCall)]
	fake.getAudioLevelArgsForCall = append(fake.getAudioLevelArgsForCall, struct {
	}{})
	stub := fake.GetAudioLevelStub
	fakeReturns := fake.getAudioLevelReturns
	fake.recordInvocation("GetAudioLevel", []interface{}{})
	fake.getAudioLevelMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeParticipant) GetAudioLevelCallCount() int {
	fake.getAudioLevelMutex.RLock()
	defer fake.getAudioLevelMutex.RUnlock()
	return len(fake.getAudioLevelArgsForCall)
}

func (fake *FakeParticipant) GetAudioLevelCalls(stub func() (uint8, bool)) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = stub
}

func (fake *FakeParticipant) GetAudioLevelReturns(result1 uint8, result2 bool) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = nil
	fake.getAudioLevelReturns = struct {
		result1 uint8
		result2 bool
	}{result1, result2}
}

func (fake *FakeParticipant) GetAudioLevelReturnsOnCall(i int, result1 uint8, result2 bool) {
	fake.getAudioLevelMutex.Lock()
	defer fake.getAudioLevelMutex.Unlock()
	fake.GetAudioLevelStub = nil
	if fake.getAudioLevelReturnsOnCall == nil {
		fake.getAudioLevelReturnsOnCall = make(map[int]struct {
			result1 uint8
			result2 bool
		})
	}
	fake.getAudioLevelReturnsOnCall[i] = struct {
		result1 uint8
		result2 bool
	}{result1, result2}
}

func (fake *FakeParticipant) GetResponseSink() routing.MessageSink {
	fake.getResponseSinkMutex.Lock()
	ret, specificReturn := fake.getResponseSinkReturnsOnCall[len(fake.getResponseSinkArgsForCall)]
	fake.getResponseSinkArgsForCall = append(fake.getResponseSinkArgsForCall, struct {
	}{})
	stub := fake.GetResponseSinkStub
	fakeReturns := fake.getResponseSinkReturns
	fake.recordInvocation("GetResponseSink", []interface{}{})
	fake.getResponseSinkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) GetResponseSinkCallCount() int {
	fake.getResponseSinkMutex.RLock()
	defer fake.getResponseSinkMutex.RUnlock()
	return len(fake.getResponseSinkArgsForCall)
}

func (fake *FakeParticipant) GetResponseSinkCalls(stub func() routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = stub
}

func (fake *FakeParticipant) GetResponseSinkReturns(result1 routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = nil
	fake.getResponseSinkReturns = struct {
		result1 routing.MessageSink
	}{result1}
}

func (fake *FakeParticipant) GetResponseSinkReturnsOnCall(i int, result1 routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = nil
	if fake.getResponseSinkReturnsOnCall == nil {
		fake.getResponseSinkReturnsOnCall = make(map[int]struct {
			result1 routing.MessageSink
		})
	}
	fake.getResponseSinkReturnsOnCall[i] = struct {
		result1 routing.MessageSink
	}{result1}
}

func (fake *FakeParticipant) HandleAnswer(arg1 webrtc.SessionDescription) error {
	fake.handleAnswerMutex.Lock()
	ret, specificReturn := fake.handleAnswerReturnsOnCall[len(fake.handleAnswerArgsForCall)]
	fake.handleAnswerArgsForCall = append(fake.handleAnswerArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.HandleAnswerStub
	fakeReturns := fake.handleAnswerReturns
	fake.recordInvocation("HandleAnswer", []interface{}{arg1})
	fake.handleAnswerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) HandleAnswerCallCount() int {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	return len(fake.handleAnswerArgsForCall)
}

func (fake *FakeParticipant) HandleAnswerCalls(stub func(webrtc.SessionDescription) error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = stub
}

func (fake *FakeParticipant) HandleAnswerArgsForCall(i int) webrtc.SessionDescription {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	argsForCall := fake.handleAnswerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) HandleAnswerReturns(result1 error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = nil
	fake.handleAnswerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) HandleAnswerReturnsOnCall(i int, result1 error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = nil
	if fake.handleAnswerReturnsOnCall == nil {
		fake.handleAnswerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.handleAnswerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) HandleOffer(arg1 webrtc.SessionDescription) (webrtc.SessionDescription, error) {
	fake.handleOfferMutex.Lock()
	ret, specificReturn := fake.handleOfferReturnsOnCall[len(fake.handleOfferArgsForCall)]
	fake.handleOfferArgsForCall = append(fake.handleOfferArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.HandleOfferStub
	fakeReturns := fake.handleOfferReturns
	fake.recordInvocation("HandleOffer", []interface{}{arg1})
	fake.handleOfferMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeParticipant) HandleOfferCallCount() int {
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	return len(fake.handleOfferArgsForCall)
}

func (fake *FakeParticipant) HandleOfferCalls(stub func(webrtc.SessionDescription) (webrtc.SessionDescription, error)) {
	fake.handleOfferMutex.Lock()
	defer fake.handleOfferMutex.Unlock()
	fake.HandleOfferStub = stub
}

func (fake *FakeParticipant) HandleOfferArgsForCall(i int) webrtc.SessionDescription {
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	argsForCall := fake.handleOfferArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) HandleOfferReturns(result1 webrtc.SessionDescription, result2 error) {
	fake.handleOfferMutex.Lock()
	defer fake.handleOfferMutex.Unlock()
	fake.HandleOfferStub = nil
	fake.handleOfferReturns = struct {
		result1 webrtc.SessionDescription
		result2 error
	}{result1, result2}
}

func (fake *FakeParticipant) HandleOfferReturnsOnCall(i int, result1 webrtc.SessionDescription, result2 error) {
	fake.handleOfferMutex.Lock()
	defer fake.handleOfferMutex.Unlock()
	fake.HandleOfferStub = nil
	if fake.handleOfferReturnsOnCall == nil {
		fake.handleOfferReturnsOnCall = make(map[int]struct {
			result1 webrtc.SessionDescription
			result2 error
		})
	}
	fake.handleOfferReturnsOnCall[i] = struct {
		result1 webrtc.SessionDescription
		result2 error
	}{result1, result2}
}

func (fake *FakeParticipant) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeParticipant) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeParticipant) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) Identity() string {
	fake.identityMutex.Lock()
	ret, specificReturn := fake.identityReturnsOnCall[len(fake.identityArgsForCall)]
	fake.identityArgsForCall = append(fake.identityArgsForCall, struct {
	}{})
	stub := fake.IdentityStub
	fakeReturns := fake.identityReturns
	fake.recordInvocation("Identity", []interface{}{})
	fake.identityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IdentityCallCount() int {
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	return len(fake.identityArgsForCall)
}

func (fake *FakeParticipant) IdentityCalls(stub func() string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = stub
}

func (fake *FakeParticipant) IdentityReturns(result1 string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	fake.identityReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IdentityReturnsOnCall(i int, result1 string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	if fake.identityReturnsOnCall == nil {
		fake.identityReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.identityReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IsReady() bool {
	fake.isReadyMutex.Lock()
	ret, specificReturn := fake.isReadyReturnsOnCall[len(fake.isReadyArgsForCall)]
	fake.isReadyArgsForCall = append(fake.isReadyArgsForCall, struct {
	}{})
	stub := fake.IsReadyStub
	fakeReturns := fake.isReadyReturns
	fake.recordInvocation("IsReady", []interface{}{})
	fake.isReadyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IsReadyCallCount() int {
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	return len(fake.isReadyArgsForCall)
}

func (fake *FakeParticipant) IsReadyCalls(stub func() bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = stub
}

func (fake *FakeParticipant) IsReadyReturns(result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	fake.isReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeParticipant) IsReadyReturnsOnCall(i int, result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	if fake.isReadyReturnsOnCall == nil {
		fake.isReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeParticipant) OnClose(arg1 func(types.Participant)) {
	fake.onCloseMutex.Lock()
	fake.onCloseArgsForCall = append(fake.onCloseArgsForCall, struct {
		arg1 func(types.Participant)
	}{arg1})
	stub := fake.OnCloseStub
	fake.recordInvocation("OnClose", []interface{}{arg1})
	fake.onCloseMutex.Unlock()
	if stub != nil {
		fake.OnCloseStub(arg1)
	}
}

func (fake *FakeParticipant) OnCloseCallCount() int {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	return len(fake.onCloseArgsForCall)
}

func (fake *FakeParticipant) OnCloseCalls(stub func(func(types.Participant))) {
	fake.onCloseMutex.Lock()
	defer fake.onCloseMutex.Unlock()
	fake.OnCloseStub = stub
}

func (fake *FakeParticipant) OnCloseArgsForCall(i int) func(types.Participant) {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	argsForCall := fake.onCloseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnStateChange(arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)) {
	fake.onStateChangeMutex.Lock()
	fake.onStateChangeArgsForCall = append(fake.onStateChangeArgsForCall, struct {
		arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)
	}{arg1})
	stub := fake.OnStateChangeStub
	fake.recordInvocation("OnStateChange", []interface{}{arg1})
	fake.onStateChangeMutex.Unlock()
	if stub != nil {
		fake.OnStateChangeStub(arg1)
	}
}

func (fake *FakeParticipant) OnStateChangeCallCount() int {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	return len(fake.onStateChangeArgsForCall)
}

func (fake *FakeParticipant) OnStateChangeCalls(stub func(func(p types.Participant, oldState livekit.ParticipantInfo_State))) {
	fake.onStateChangeMutex.Lock()
	defer fake.onStateChangeMutex.Unlock()
	fake.OnStateChangeStub = stub
}

func (fake *FakeParticipant) OnStateChangeArgsForCall(i int) func(p types.Participant, oldState livekit.ParticipantInfo_State) {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	argsForCall := fake.onStateChangeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnTrackPublished(arg1 func(types.Participant, types.PublishedTrack)) {
	fake.onTrackPublishedMutex.Lock()
	fake.onTrackPublishedArgsForCall = append(fake.onTrackPublishedArgsForCall, struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}{arg1})
	stub := fake.OnTrackPublishedStub
	fake.recordInvocation("OnTrackPublished", []interface{}{arg1})
	fake.onTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackPublishedStub(arg1)
	}
}

func (fake *FakeParticipant) OnTrackPublishedCallCount() int {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	return len(fake.onTrackPublishedArgsForCall)
}

func (fake *FakeParticipant) OnTrackPublishedCalls(stub func(func(types.Participant, types.PublishedTrack))) {
	fake.onTrackPublishedMutex.Lock()
	defer fake.onTrackPublishedMutex.Unlock()
	fake.OnTrackPublishedStub = stub
}

func (fake *FakeParticipant) OnTrackPublishedArgsForCall(i int) func(types.Participant, types.PublishedTrack) {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	argsForCall := fake.onTrackPublishedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnTrackUpdated(arg1 func(types.Participant, types.PublishedTrack)) {
	fake.onTrackUpdatedMutex.Lock()
	fake.onTrackUpdatedArgsForCall = append(fake.onTrackUpdatedArgsForCall, struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}{arg1})
	stub := fake.OnTrackUpdatedStub
	fake.recordInvocation("OnTrackUpdated", []interface{}{arg1})
	fake.onTrackUpdatedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUpdatedStub(arg1)
	}
}

func (fake *FakeParticipant) OnTrackUpdatedCallCount() int {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	return len(fake.onTrackUpdatedArgsForCall)
}

func (fake *FakeParticipant) OnTrackUpdatedCalls(stub func(func(types.Participant, types.PublishedTrack))) {
	fake.onTrackUpdatedMutex.Lock()
	defer fake.onTrackUpdatedMutex.Unlock()
	fake.OnTrackUpdatedStub = stub
}

func (fake *FakeParticipant) OnTrackUpdatedArgsForCall(i int) func(types.Participant, types.PublishedTrack) {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	argsForCall := fake.onTrackUpdatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) RTCPChan() chan []rtcp.Packet {
	fake.rTCPChanMutex.Lock()
	ret, specificReturn := fake.rTCPChanReturnsOnCall[len(fake.rTCPChanArgsForCall)]
	fake.rTCPChanArgsForCall = append(fake.rTCPChanArgsForCall, struct {
	}{})
	stub := fake.RTCPChanStub
	fakeReturns := fake.rTCPChanReturns
	fake.recordInvocation("RTCPChan", []interface{}{})
	fake.rTCPChanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) RTCPChanCallCount() int {
	fake.rTCPChanMutex.RLock()
	defer fake.rTCPChanMutex.RUnlock()
	return len(fake.rTCPChanArgsForCall)
}

func (fake *FakeParticipant) RTCPChanCalls(stub func() chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = stub
}

func (fake *FakeParticipant) RTCPChanReturns(result1 chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = nil
	fake.rTCPChanReturns = struct {
		result1 chan []rtcp.Packet
	}{result1}
}

func (fake *FakeParticipant) RTCPChanReturnsOnCall(i int, result1 chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = nil
	if fake.rTCPChanReturnsOnCall == nil {
		fake.rTCPChanReturnsOnCall = make(map[int]struct {
			result1 chan []rtcp.Packet
		})
	}
	fake.rTCPChanReturnsOnCall[i] = struct {
		result1 chan []rtcp.Packet
	}{result1}
}

func (fake *FakeParticipant) RemoveSubscribedTrack(arg1 string, arg2 types.SubscribedTrack) {
	fake.removeSubscribedTrackMutex.Lock()
	fake.removeSubscribedTrackArgsForCall = append(fake.removeSubscribedTrackArgsForCall, struct {
		arg1 string
		arg2 types.SubscribedTrack
	}{arg1, arg2})
	stub := fake.RemoveSubscribedTrackStub
	fake.recordInvocation("RemoveSubscribedTrack", []interface{}{arg1, arg2})
	fake.removeSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscribedTrackStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) RemoveSubscribedTrackCallCount() int {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	return len(fake.removeSubscribedTrackArgsForCall)
}

func (fake *FakeParticipant) RemoveSubscribedTrackCalls(stub func(string, types.SubscribedTrack)) {
	fake.removeSubscribedTrackMutex.Lock()
	defer fake.removeSubscribedTrackMutex.Unlock()
	fake.RemoveSubscribedTrackStub = stub
}

func (fake *FakeParticipant) RemoveSubscribedTrackArgsForCall(i int) (string, types.SubscribedTrack) {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	argsForCall := fake.removeSubscribedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) RemoveSubscriber(arg1 string) {
	fake.removeSubscriberMutex.Lock()
	fake.removeSubscriberArgsForCall = append(fake.removeSubscriberArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveSubscriberStub
	fake.recordInvocation("RemoveSubscriber", []interface{}{arg1})
	fake.removeSubscriberMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscriberStub(arg1)
	}
}

func (fake *FakeParticipant) RemoveSubscriberCallCount() int {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	return len(fake.removeSubscriberArgsForCall)
}

func (fake *FakeParticipant) RemoveSubscriberCalls(stub func(string)) {
	fake.removeSubscriberMutex.Lock()
	defer fake.removeSubscriberMutex.Unlock()
	fake.RemoveSubscriberStub = stub
}

func (fake *FakeParticipant) RemoveSubscriberArgsForCall(i int) string {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	argsForCall := fake.removeSubscriberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SendActiveSpeakers(arg1 []*livekit.SpeakerInfo) error {
	var arg1Copy []*livekit.SpeakerInfo
	if arg1 != nil {
		arg1Copy = make([]*livekit.SpeakerInfo, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendActiveSpeakersMutex.Lock()
	ret, specificReturn := fake.sendActiveSpeakersReturnsOnCall[len(fake.sendActiveSpeakersArgsForCall)]
	fake.sendActiveSpeakersArgsForCall = append(fake.sendActiveSpeakersArgsForCall, struct {
		arg1 []*livekit.SpeakerInfo
	}{arg1Copy})
	stub := fake.SendActiveSpeakersStub
	fakeReturns := fake.sendActiveSpeakersReturns
	fake.recordInvocation("SendActiveSpeakers", []interface{}{arg1Copy})
	fake.sendActiveSpeakersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SendActiveSpeakersCallCount() int {
	fake.sendActiveSpeakersMutex.RLock()
	defer fake.sendActiveSpeakersMutex.RUnlock()
	return len(fake.sendActiveSpeakersArgsForCall)
}

func (fake *FakeParticipant) SendActiveSpeakersCalls(stub func([]*livekit.SpeakerInfo) error) {
	fake.sendActiveSpeakersMutex.Lock()
	defer fake.sendActiveSpeakersMutex.Unlock()
	fake.SendActiveSpeakersStub = stub
}

func (fake *FakeParticipant) SendActiveSpeakersArgsForCall(i int) []*livekit.SpeakerInfo {
	fake.sendActiveSpeakersMutex.RLock()
	defer fake.sendActiveSpeakersMutex.RUnlock()
	argsForCall := fake.sendActiveSpeakersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SendActiveSpeakersReturns(result1 error) {
	fake.sendActiveSpeakersMutex.Lock()
	defer fake.sendActiveSpeakersMutex.Unlock()
	fake.SendActiveSpeakersStub = nil
	fake.sendActiveSpeakersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendActiveSpeakersReturnsOnCall(i int, result1 error) {
	fake.sendActiveSpeakersMutex.Lock()
	defer fake.sendActiveSpeakersMutex.Unlock()
	fake.SendActiveSpeakersStub = nil
	if fake.sendActiveSpeakersReturnsOnCall == nil {
		fake.sendActiveSpeakersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendActiveSpeakersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendJoinResponse(arg1 *livekit.Room, arg2 []types.Participant) error {
	var arg2Copy []types.Participant
	if arg2 != nil {
		arg2Copy = make([]types.Participant, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sendJoinResponseMutex.Lock()
	ret, specificReturn := fake.sendJoinResponseReturnsOnCall[len(fake.sendJoinResponseArgsForCall)]
	fake.sendJoinResponseArgsForCall = append(fake.sendJoinResponseArgsForCall, struct {
		arg1 *livekit.Room
		arg2 []types.Participant
	}{arg1, arg2Copy})
	stub := fake.SendJoinResponseStub
	fakeReturns := fake.sendJoinResponseReturns
	fake.recordInvocation("SendJoinResponse", []interface{}{arg1, arg2Copy})
	fake.sendJoinResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SendJoinResponseCallCount() int {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	return len(fake.sendJoinResponseArgsForCall)
}

func (fake *FakeParticipant) SendJoinResponseCalls(stub func(*livekit.Room, []types.Participant) error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = stub
}

func (fake *FakeParticipant) SendJoinResponseArgsForCall(i int) (*livekit.Room, []types.Participant) {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	argsForCall := fake.sendJoinResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) SendJoinResponseReturns(result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	fake.sendJoinResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendJoinResponseReturnsOnCall(i int, result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	if fake.sendJoinResponseReturnsOnCall == nil {
		fake.sendJoinResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendJoinResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendParticipantUpdate(arg1 []*livekit.ParticipantInfo) error {
	var arg1Copy []*livekit.ParticipantInfo
	if arg1 != nil {
		arg1Copy = make([]*livekit.ParticipantInfo, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendParticipantUpdateMutex.Lock()
	ret, specificReturn := fake.sendParticipantUpdateReturnsOnCall[len(fake.sendParticipantUpdateArgsForCall)]
	fake.sendParticipantUpdateArgsForCall = append(fake.sendParticipantUpdateArgsForCall, struct {
		arg1 []*livekit.ParticipantInfo
	}{arg1Copy})
	stub := fake.SendParticipantUpdateStub
	fakeReturns := fake.sendParticipantUpdateReturns
	fake.recordInvocation("SendParticipantUpdate", []interface{}{arg1Copy})
	fake.sendParticipantUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SendParticipantUpdateCallCount() int {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	return len(fake.sendParticipantUpdateArgsForCall)
}

func (fake *FakeParticipant) SendParticipantUpdateCalls(stub func([]*livekit.ParticipantInfo) error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = stub
}

func (fake *FakeParticipant) SendParticipantUpdateArgsForCall(i int) []*livekit.ParticipantInfo {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	argsForCall := fake.sendParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SendParticipantUpdateReturns(result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	fake.sendParticipantUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendParticipantUpdateReturnsOnCall(i int, result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	if fake.sendParticipantUpdateReturnsOnCall == nil {
		fake.sendParticipantUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendParticipantUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetMetadata(arg1 map[string]interface{}) error {
	fake.setMetadataMutex.Lock()
	ret, specificReturn := fake.setMetadataReturnsOnCall[len(fake.setMetadataArgsForCall)]
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		arg1 map[string]interface{}
	}{arg1})
	stub := fake.SetMetadataStub
	fakeReturns := fake.setMetadataReturns
	fake.recordInvocation("SetMetadata", []interface{}{arg1})
	fake.setMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeParticipant) SetMetadataCalls(stub func(map[string]interface{}) error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = stub
}

func (fake *FakeParticipant) SetMetadataArgsForCall(i int) map[string]interface{} {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	argsForCall := fake.setMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SetMetadataReturns(result1 error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = nil
	fake.setMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetMetadataReturnsOnCall(i int, result1 error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = nil
	if fake.setMetadataReturnsOnCall == nil {
		fake.setMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetResponseSink(arg1 routing.MessageSink) {
	fake.setResponseSinkMutex.Lock()
	fake.setResponseSinkArgsForCall = append(fake.setResponseSinkArgsForCall, struct {
		arg1 routing.MessageSink
	}{arg1})
	stub := fake.SetResponseSinkStub
	fake.recordInvocation("SetResponseSink", []interface{}{arg1})
	fake.setResponseSinkMutex.Unlock()
	if stub != nil {
		fake.SetResponseSinkStub(arg1)
	}
}

func (fake *FakeParticipant) SetResponseSinkCallCount() int {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	return len(fake.setResponseSinkArgsForCall)
}

func (fake *FakeParticipant) SetResponseSinkCalls(stub func(routing.MessageSink)) {
	fake.setResponseSinkMutex.Lock()
	defer fake.setResponseSinkMutex.Unlock()
	fake.SetResponseSinkStub = stub
}

func (fake *FakeParticipant) SetResponseSinkArgsForCall(i int) routing.MessageSink {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	argsForCall := fake.setResponseSinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SetTrackMuted(arg1 string, arg2 bool) {
	fake.setTrackMutedMutex.Lock()
	fake.setTrackMutedArgsForCall = append(fake.setTrackMutedArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.SetTrackMutedStub
	fake.recordInvocation("SetTrackMuted", []interface{}{arg1, arg2})
	fake.setTrackMutedMutex.Unlock()
	if stub != nil {
		fake.SetTrackMutedStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) SetTrackMutedCallCount() int {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	return len(fake.setTrackMutedArgsForCall)
}

func (fake *FakeParticipant) SetTrackMutedCalls(stub func(string, bool)) {
	fake.setTrackMutedMutex.Lock()
	defer fake.setTrackMutedMutex.Unlock()
	fake.SetTrackMutedStub = stub
}

func (fake *FakeParticipant) SetTrackMutedArgsForCall(i int) (string, bool) {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	argsForCall := fake.setTrackMutedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	stub := fake.StartStub
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if stub != nil {
		fake.StartStub()
	}
}

func (fake *FakeParticipant) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeParticipant) StartCalls(stub func()) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeParticipant) State() livekit.ParticipantInfo_State {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeParticipant) StateCalls(stub func() livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeParticipant) StateReturns(result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeParticipant) StateReturnsOnCall(i int, result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 livekit.ParticipantInfo_State
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeParticipant) SubscriberMediaEngine() *webrtc.MediaEngine {
	fake.subscriberMediaEngineMutex.Lock()
	ret, specificReturn := fake.subscriberMediaEngineReturnsOnCall[len(fake.subscriberMediaEngineArgsForCall)]
	fake.subscriberMediaEngineArgsForCall = append(fake.subscriberMediaEngineArgsForCall, struct {
	}{})
	stub := fake.SubscriberMediaEngineStub
	fakeReturns := fake.subscriberMediaEngineReturns
	fake.recordInvocation("SubscriberMediaEngine", []interface{}{})
	fake.subscriberMediaEngineMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SubscriberMediaEngineCallCount() int {
	fake.subscriberMediaEngineMutex.RLock()
	defer fake.subscriberMediaEngineMutex.RUnlock()
	return len(fake.subscriberMediaEngineArgsForCall)
}

func (fake *FakeParticipant) SubscriberMediaEngineCalls(stub func() *webrtc.MediaEngine) {
	fake.subscriberMediaEngineMutex.Lock()
	defer fake.subscriberMediaEngineMutex.Unlock()
	fake.SubscriberMediaEngineStub = stub
}

func (fake *FakeParticipant) SubscriberMediaEngineReturns(result1 *webrtc.MediaEngine) {
	fake.subscriberMediaEngineMutex.Lock()
	defer fake.subscriberMediaEngineMutex.Unlock()
	fake.SubscriberMediaEngineStub = nil
	fake.subscriberMediaEngineReturns = struct {
		result1 *webrtc.MediaEngine
	}{result1}
}

func (fake *FakeParticipant) SubscriberMediaEngineReturnsOnCall(i int, result1 *webrtc.MediaEngine) {
	fake.subscriberMediaEngineMutex.Lock()
	defer fake.subscriberMediaEngineMutex.Unlock()
	fake.SubscriberMediaEngineStub = nil
	if fake.subscriberMediaEngineReturnsOnCall == nil {
		fake.subscriberMediaEngineReturnsOnCall = make(map[int]struct {
			result1 *webrtc.MediaEngine
		})
	}
	fake.subscriberMediaEngineReturnsOnCall[i] = struct {
		result1 *webrtc.MediaEngine
	}{result1}
}

func (fake *FakeParticipant) SubscriberPC() *webrtc.PeerConnection {
	fake.subscriberPCMutex.Lock()
	ret, specificReturn := fake.subscriberPCReturnsOnCall[len(fake.subscriberPCArgsForCall)]
	fake.subscriberPCArgsForCall = append(fake.subscriberPCArgsForCall, struct {
	}{})
	stub := fake.SubscriberPCStub
	fakeReturns := fake.subscriberPCReturns
	fake.recordInvocation("SubscriberPC", []interface{}{})
	fake.subscriberPCMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SubscriberPCCallCount() int {
	fake.subscriberPCMutex.RLock()
	defer fake.subscriberPCMutex.RUnlock()
	return len(fake.subscriberPCArgsForCall)
}

func (fake *FakeParticipant) SubscriberPCCalls(stub func() *webrtc.PeerConnection) {
	fake.subscriberPCMutex.Lock()
	defer fake.subscriberPCMutex.Unlock()
	fake.SubscriberPCStub = stub
}

func (fake *FakeParticipant) SubscriberPCReturns(result1 *webrtc.PeerConnection) {
	fake.subscriberPCMutex.Lock()
	defer fake.subscriberPCMutex.Unlock()
	fake.SubscriberPCStub = nil
	fake.subscriberPCReturns = struct {
		result1 *webrtc.PeerConnection
	}{result1}
}

func (fake *FakeParticipant) SubscriberPCReturnsOnCall(i int, result1 *webrtc.PeerConnection) {
	fake.subscriberPCMutex.Lock()
	defer fake.subscriberPCMutex.Unlock()
	fake.SubscriberPCStub = nil
	if fake.subscriberPCReturnsOnCall == nil {
		fake.subscriberPCReturnsOnCall = make(map[int]struct {
			result1 *webrtc.PeerConnection
		})
	}
	fake.subscriberPCReturnsOnCall[i] = struct {
		result1 *webrtc.PeerConnection
	}{result1}
}

func (fake *FakeParticipant) ToProto() *livekit.ParticipantInfo {
	fake.toProtoMutex.Lock()
	ret, specificReturn := fake.toProtoReturnsOnCall[len(fake.toProtoArgsForCall)]
	fake.toProtoArgsForCall = append(fake.toProtoArgsForCall, struct {
	}{})
	stub := fake.ToProtoStub
	fakeReturns := fake.toProtoReturns
	fake.recordInvocation("ToProto", []interface{}{})
	fake.toProtoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) ToProtoCallCount() int {
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	return len(fake.toProtoArgsForCall)
}

func (fake *FakeParticipant) ToProtoCalls(stub func() *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = stub
}

func (fake *FakeParticipant) ToProtoReturns(result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	fake.toProtoReturns = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeParticipant) ToProtoReturnsOnCall(i int, result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	if fake.toProtoReturnsOnCall == nil {
		fake.toProtoReturnsOnCall = make(map[int]struct {
			result1 *livekit.ParticipantInfo
		})
	}
	fake.toProtoReturnsOnCall[i] = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeParticipant) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.getAudioLevelMutex.RLock()
	defer fake.getAudioLevelMutex.RUnlock()
	fake.getResponseSinkMutex.RLock()
	defer fake.getResponseSinkMutex.RUnlock()
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	fake.handleOfferMutex.RLock()
	defer fake.handleOfferMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	fake.rTCPChanMutex.RLock()
	defer fake.rTCPChanMutex.RUnlock()
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	fake.sendActiveSpeakersMutex.RLock()
	defer fake.sendActiveSpeakersMutex.RUnlock()
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.subscriberMediaEngineMutex.RLock()
	defer fake.subscriberMediaEngineMutex.RUnlock()
	fake.subscriberPCMutex.RLock()
	defer fake.subscriberPCMutex.RUnlock()
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeParticipant) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.Participant = new(FakeParticipant)
