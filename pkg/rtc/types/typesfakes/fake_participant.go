// Code generated by counterfeiter. DO NOT EDIT.
package typesfakes

import (
	"sync"

	"github.com/livekit/livekit-server/pkg/routing"
	"github.com/livekit/livekit-server/pkg/rtc/types"
	"github.com/livekit/livekit-server/proto/livekit"
	"github.com/pion/rtcp"
	webrtc "github.com/pion/webrtc/v3"
)

type FakeParticipant struct {
	AddICECandidateStub        func(webrtc.ICECandidateInit) error
	addICECandidateMutex       sync.RWMutex
	addICECandidateArgsForCall []struct {
		arg1 webrtc.ICECandidateInit
	}
	addICECandidateReturns struct {
		result1 error
	}
	addICECandidateReturnsOnCall map[int]struct {
		result1 error
	}
	AddSubscribedTrackStub        func(string, types.SubscribedTrack)
	addSubscribedTrackMutex       sync.RWMutex
	addSubscribedTrackArgsForCall []struct {
		arg1 string
		arg2 types.SubscribedTrack
	}
	AddSubscriberStub        func(types.Participant) error
	addSubscriberMutex       sync.RWMutex
	addSubscriberArgsForCall []struct {
		arg1 types.Participant
	}
	addSubscriberReturns struct {
		result1 error
	}
	addSubscriberReturnsOnCall map[int]struct {
		result1 error
	}
	AddTrackStub        func(string, string, livekit.TrackType)
	addTrackMutex       sync.RWMutex
	addTrackArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 livekit.TrackType
	}
	AnswerStub        func(webrtc.SessionDescription) (webrtc.SessionDescription, error)
	answerMutex       sync.RWMutex
	answerArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	answerReturns struct {
		result1 webrtc.SessionDescription
		result2 error
	}
	answerReturnsOnCall map[int]struct {
		result1 webrtc.SessionDescription
		result2 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	GetResponseSinkStub        func() routing.MessageSink
	getResponseSinkMutex       sync.RWMutex
	getResponseSinkArgsForCall []struct {
	}
	getResponseSinkReturns struct {
		result1 routing.MessageSink
	}
	getResponseSinkReturnsOnCall map[int]struct {
		result1 routing.MessageSink
	}
	HandleAnswerStub        func(webrtc.SessionDescription) error
	handleAnswerMutex       sync.RWMutex
	handleAnswerArgsForCall []struct {
		arg1 webrtc.SessionDescription
	}
	handleAnswerReturns struct {
		result1 error
	}
	handleAnswerReturnsOnCall map[int]struct {
		result1 error
	}
	HandleClientNegotiationStub        func()
	handleClientNegotiationMutex       sync.RWMutex
	handleClientNegotiationArgsForCall []struct {
	}
	IDStub        func() string
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 string
	}
	iDReturnsOnCall map[int]struct {
		result1 string
	}
	IdentityStub        func() string
	identityMutex       sync.RWMutex
	identityArgsForCall []struct {
	}
	identityReturns struct {
		result1 string
	}
	identityReturnsOnCall map[int]struct {
		result1 string
	}
	IsReadyStub        func() bool
	isReadyMutex       sync.RWMutex
	isReadyArgsForCall []struct {
	}
	isReadyReturns struct {
		result1 bool
	}
	isReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	OnCloseStub        func(func(types.Participant))
	onCloseMutex       sync.RWMutex
	onCloseArgsForCall []struct {
		arg1 func(types.Participant)
	}
	OnICECandidateStub        func(func(c *webrtc.ICECandidateInit))
	onICECandidateMutex       sync.RWMutex
	onICECandidateArgsForCall []struct {
		arg1 func(c *webrtc.ICECandidateInit)
	}
	OnStateChangeStub        func(func(p types.Participant, oldState livekit.ParticipantInfo_State))
	onStateChangeMutex       sync.RWMutex
	onStateChangeArgsForCall []struct {
		arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)
	}
	OnTrackPublishedStub        func(func(types.Participant, types.PublishedTrack))
	onTrackPublishedMutex       sync.RWMutex
	onTrackPublishedArgsForCall []struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}
	OnTrackUpdatedStub        func(func(types.Participant, types.PublishedTrack))
	onTrackUpdatedMutex       sync.RWMutex
	onTrackUpdatedArgsForCall []struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}
	PeerConnectionStub        func() types.PeerConnection
	peerConnectionMutex       sync.RWMutex
	peerConnectionArgsForCall []struct {
	}
	peerConnectionReturns struct {
		result1 types.PeerConnection
	}
	peerConnectionReturnsOnCall map[int]struct {
		result1 types.PeerConnection
	}
	RTCPChanStub        func() chan []rtcp.Packet
	rTCPChanMutex       sync.RWMutex
	rTCPChanArgsForCall []struct {
	}
	rTCPChanReturns struct {
		result1 chan []rtcp.Packet
	}
	rTCPChanReturnsOnCall map[int]struct {
		result1 chan []rtcp.Packet
	}
	RemoveSubscribedTrackStub        func(string, types.SubscribedTrack)
	removeSubscribedTrackMutex       sync.RWMutex
	removeSubscribedTrackArgsForCall []struct {
		arg1 string
		arg2 types.SubscribedTrack
	}
	RemoveSubscriberStub        func(string)
	removeSubscriberMutex       sync.RWMutex
	removeSubscriberArgsForCall []struct {
		arg1 string
	}
	SendJoinResponseStub        func(*livekit.Room, []types.Participant) error
	sendJoinResponseMutex       sync.RWMutex
	sendJoinResponseArgsForCall []struct {
		arg1 *livekit.Room
		arg2 []types.Participant
	}
	sendJoinResponseReturns struct {
		result1 error
	}
	sendJoinResponseReturnsOnCall map[int]struct {
		result1 error
	}
	SendParticipantUpdateStub        func([]*livekit.ParticipantInfo) error
	sendParticipantUpdateMutex       sync.RWMutex
	sendParticipantUpdateArgsForCall []struct {
		arg1 []*livekit.ParticipantInfo
	}
	sendParticipantUpdateReturns struct {
		result1 error
	}
	sendParticipantUpdateReturnsOnCall map[int]struct {
		result1 error
	}
	SetMetadataStub        func(map[string]interface{}) error
	setMetadataMutex       sync.RWMutex
	setMetadataArgsForCall []struct {
		arg1 map[string]interface{}
	}
	setMetadataReturns struct {
		result1 error
	}
	setMetadataReturnsOnCall map[int]struct {
		result1 error
	}
	SetResponseSinkStub        func(routing.MessageSink)
	setResponseSinkMutex       sync.RWMutex
	setResponseSinkArgsForCall []struct {
		arg1 routing.MessageSink
	}
	SetTrackMutedStub        func(string, bool)
	setTrackMutedMutex       sync.RWMutex
	setTrackMutedArgsForCall []struct {
		arg1 string
		arg2 bool
	}
	StartStub        func()
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	StateStub        func() livekit.ParticipantInfo_State
	stateMutex       sync.RWMutex
	stateArgsForCall []struct {
	}
	stateReturns struct {
		result1 livekit.ParticipantInfo_State
	}
	stateReturnsOnCall map[int]struct {
		result1 livekit.ParticipantInfo_State
	}
	ToProtoStub        func() *livekit.ParticipantInfo
	toProtoMutex       sync.RWMutex
	toProtoArgsForCall []struct {
	}
	toProtoReturns struct {
		result1 *livekit.ParticipantInfo
	}
	toProtoReturnsOnCall map[int]struct {
		result1 *livekit.ParticipantInfo
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeParticipant) AddICECandidate(arg1 webrtc.ICECandidateInit) error {
	fake.addICECandidateMutex.Lock()
	ret, specificReturn := fake.addICECandidateReturnsOnCall[len(fake.addICECandidateArgsForCall)]
	fake.addICECandidateArgsForCall = append(fake.addICECandidateArgsForCall, struct {
		arg1 webrtc.ICECandidateInit
	}{arg1})
	stub := fake.AddICECandidateStub
	fakeReturns := fake.addICECandidateReturns
	fake.recordInvocation("AddICECandidate", []interface{}{arg1})
	fake.addICECandidateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) AddICECandidateCallCount() int {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	return len(fake.addICECandidateArgsForCall)
}

func (fake *FakeParticipant) AddICECandidateCalls(stub func(webrtc.ICECandidateInit) error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = stub
}

func (fake *FakeParticipant) AddICECandidateArgsForCall(i int) webrtc.ICECandidateInit {
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	argsForCall := fake.addICECandidateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) AddICECandidateReturns(result1 error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = nil
	fake.addICECandidateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddICECandidateReturnsOnCall(i int, result1 error) {
	fake.addICECandidateMutex.Lock()
	defer fake.addICECandidateMutex.Unlock()
	fake.AddICECandidateStub = nil
	if fake.addICECandidateReturnsOnCall == nil {
		fake.addICECandidateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addICECandidateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddSubscribedTrack(arg1 string, arg2 types.SubscribedTrack) {
	fake.addSubscribedTrackMutex.Lock()
	fake.addSubscribedTrackArgsForCall = append(fake.addSubscribedTrackArgsForCall, struct {
		arg1 string
		arg2 types.SubscribedTrack
	}{arg1, arg2})
	stub := fake.AddSubscribedTrackStub
	fake.recordInvocation("AddSubscribedTrack", []interface{}{arg1, arg2})
	fake.addSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.AddSubscribedTrackStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) AddSubscribedTrackCallCount() int {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	return len(fake.addSubscribedTrackArgsForCall)
}

func (fake *FakeParticipant) AddSubscribedTrackCalls(stub func(string, types.SubscribedTrack)) {
	fake.addSubscribedTrackMutex.Lock()
	defer fake.addSubscribedTrackMutex.Unlock()
	fake.AddSubscribedTrackStub = stub
}

func (fake *FakeParticipant) AddSubscribedTrackArgsForCall(i int) (string, types.SubscribedTrack) {
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	argsForCall := fake.addSubscribedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) AddSubscriber(arg1 types.Participant) error {
	fake.addSubscriberMutex.Lock()
	ret, specificReturn := fake.addSubscriberReturnsOnCall[len(fake.addSubscriberArgsForCall)]
	fake.addSubscriberArgsForCall = append(fake.addSubscriberArgsForCall, struct {
		arg1 types.Participant
	}{arg1})
	stub := fake.AddSubscriberStub
	fakeReturns := fake.addSubscriberReturns
	fake.recordInvocation("AddSubscriber", []interface{}{arg1})
	fake.addSubscriberMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) AddSubscriberCallCount() int {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	return len(fake.addSubscriberArgsForCall)
}

func (fake *FakeParticipant) AddSubscriberCalls(stub func(types.Participant) error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = stub
}

func (fake *FakeParticipant) AddSubscriberArgsForCall(i int) types.Participant {
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	argsForCall := fake.addSubscriberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) AddSubscriberReturns(result1 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	fake.addSubscriberReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddSubscriberReturnsOnCall(i int, result1 error) {
	fake.addSubscriberMutex.Lock()
	defer fake.addSubscriberMutex.Unlock()
	fake.AddSubscriberStub = nil
	if fake.addSubscriberReturnsOnCall == nil {
		fake.addSubscriberReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addSubscriberReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) AddTrack(arg1 string, arg2 string, arg3 livekit.TrackType) {
	fake.addTrackMutex.Lock()
	fake.addTrackArgsForCall = append(fake.addTrackArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 livekit.TrackType
	}{arg1, arg2, arg3})
	stub := fake.AddTrackStub
	fake.recordInvocation("AddTrack", []interface{}{arg1, arg2, arg3})
	fake.addTrackMutex.Unlock()
	if stub != nil {
		fake.AddTrackStub(arg1, arg2, arg3)
	}
}

func (fake *FakeParticipant) AddTrackCallCount() int {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	return len(fake.addTrackArgsForCall)
}

func (fake *FakeParticipant) AddTrackCalls(stub func(string, string, livekit.TrackType)) {
	fake.addTrackMutex.Lock()
	defer fake.addTrackMutex.Unlock()
	fake.AddTrackStub = stub
}

func (fake *FakeParticipant) AddTrackArgsForCall(i int) (string, string, livekit.TrackType) {
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	argsForCall := fake.addTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeParticipant) Answer(arg1 webrtc.SessionDescription) (webrtc.SessionDescription, error) {
	fake.answerMutex.Lock()
	ret, specificReturn := fake.answerReturnsOnCall[len(fake.answerArgsForCall)]
	fake.answerArgsForCall = append(fake.answerArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.AnswerStub
	fakeReturns := fake.answerReturns
	fake.recordInvocation("Answer", []interface{}{arg1})
	fake.answerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeParticipant) AnswerCallCount() int {
	fake.answerMutex.RLock()
	defer fake.answerMutex.RUnlock()
	return len(fake.answerArgsForCall)
}

func (fake *FakeParticipant) AnswerCalls(stub func(webrtc.SessionDescription) (webrtc.SessionDescription, error)) {
	fake.answerMutex.Lock()
	defer fake.answerMutex.Unlock()
	fake.AnswerStub = stub
}

func (fake *FakeParticipant) AnswerArgsForCall(i int) webrtc.SessionDescription {
	fake.answerMutex.RLock()
	defer fake.answerMutex.RUnlock()
	argsForCall := fake.answerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) AnswerReturns(result1 webrtc.SessionDescription, result2 error) {
	fake.answerMutex.Lock()
	defer fake.answerMutex.Unlock()
	fake.AnswerStub = nil
	fake.answerReturns = struct {
		result1 webrtc.SessionDescription
		result2 error
	}{result1, result2}
}

func (fake *FakeParticipant) AnswerReturnsOnCall(i int, result1 webrtc.SessionDescription, result2 error) {
	fake.answerMutex.Lock()
	defer fake.answerMutex.Unlock()
	fake.AnswerStub = nil
	if fake.answerReturnsOnCall == nil {
		fake.answerReturnsOnCall = make(map[int]struct {
			result1 webrtc.SessionDescription
			result2 error
		})
	}
	fake.answerReturnsOnCall[i] = struct {
		result1 webrtc.SessionDescription
		result2 error
	}{result1, result2}
}

func (fake *FakeParticipant) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeParticipant) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeParticipant) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) GetResponseSink() routing.MessageSink {
	fake.getResponseSinkMutex.Lock()
	ret, specificReturn := fake.getResponseSinkReturnsOnCall[len(fake.getResponseSinkArgsForCall)]
	fake.getResponseSinkArgsForCall = append(fake.getResponseSinkArgsForCall, struct {
	}{})
	stub := fake.GetResponseSinkStub
	fakeReturns := fake.getResponseSinkReturns
	fake.recordInvocation("GetResponseSink", []interface{}{})
	fake.getResponseSinkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) GetResponseSinkCallCount() int {
	fake.getResponseSinkMutex.RLock()
	defer fake.getResponseSinkMutex.RUnlock()
	return len(fake.getResponseSinkArgsForCall)
}

func (fake *FakeParticipant) GetResponseSinkCalls(stub func() routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = stub
}

func (fake *FakeParticipant) GetResponseSinkReturns(result1 routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = nil
	fake.getResponseSinkReturns = struct {
		result1 routing.MessageSink
	}{result1}
}

func (fake *FakeParticipant) GetResponseSinkReturnsOnCall(i int, result1 routing.MessageSink) {
	fake.getResponseSinkMutex.Lock()
	defer fake.getResponseSinkMutex.Unlock()
	fake.GetResponseSinkStub = nil
	if fake.getResponseSinkReturnsOnCall == nil {
		fake.getResponseSinkReturnsOnCall = make(map[int]struct {
			result1 routing.MessageSink
		})
	}
	fake.getResponseSinkReturnsOnCall[i] = struct {
		result1 routing.MessageSink
	}{result1}
}

func (fake *FakeParticipant) HandleAnswer(arg1 webrtc.SessionDescription) error {
	fake.handleAnswerMutex.Lock()
	ret, specificReturn := fake.handleAnswerReturnsOnCall[len(fake.handleAnswerArgsForCall)]
	fake.handleAnswerArgsForCall = append(fake.handleAnswerArgsForCall, struct {
		arg1 webrtc.SessionDescription
	}{arg1})
	stub := fake.HandleAnswerStub
	fakeReturns := fake.handleAnswerReturns
	fake.recordInvocation("HandleAnswer", []interface{}{arg1})
	fake.handleAnswerMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) HandleAnswerCallCount() int {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	return len(fake.handleAnswerArgsForCall)
}

func (fake *FakeParticipant) HandleAnswerCalls(stub func(webrtc.SessionDescription) error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = stub
}

func (fake *FakeParticipant) HandleAnswerArgsForCall(i int) webrtc.SessionDescription {
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	argsForCall := fake.handleAnswerArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) HandleAnswerReturns(result1 error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = nil
	fake.handleAnswerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) HandleAnswerReturnsOnCall(i int, result1 error) {
	fake.handleAnswerMutex.Lock()
	defer fake.handleAnswerMutex.Unlock()
	fake.HandleAnswerStub = nil
	if fake.handleAnswerReturnsOnCall == nil {
		fake.handleAnswerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.handleAnswerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) HandleClientNegotiation() {
	fake.handleClientNegotiationMutex.Lock()
	fake.handleClientNegotiationArgsForCall = append(fake.handleClientNegotiationArgsForCall, struct {
	}{})
	stub := fake.HandleClientNegotiationStub
	fake.recordInvocation("HandleClientNegotiation", []interface{}{})
	fake.handleClientNegotiationMutex.Unlock()
	if stub != nil {
		fake.HandleClientNegotiationStub()
	}
}

func (fake *FakeParticipant) HandleClientNegotiationCallCount() int {
	fake.handleClientNegotiationMutex.RLock()
	defer fake.handleClientNegotiationMutex.RUnlock()
	return len(fake.handleClientNegotiationArgsForCall)
}

func (fake *FakeParticipant) HandleClientNegotiationCalls(stub func()) {
	fake.handleClientNegotiationMutex.Lock()
	defer fake.handleClientNegotiationMutex.Unlock()
	fake.HandleClientNegotiationStub = stub
}

func (fake *FakeParticipant) ID() string {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	stub := fake.IDStub
	fakeReturns := fake.iDReturns
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeParticipant) IDCalls(stub func() string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakeParticipant) IDReturns(result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IDReturnsOnCall(i int, result1 string) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) Identity() string {
	fake.identityMutex.Lock()
	ret, specificReturn := fake.identityReturnsOnCall[len(fake.identityArgsForCall)]
	fake.identityArgsForCall = append(fake.identityArgsForCall, struct {
	}{})
	stub := fake.IdentityStub
	fakeReturns := fake.identityReturns
	fake.recordInvocation("Identity", []interface{}{})
	fake.identityMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IdentityCallCount() int {
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	return len(fake.identityArgsForCall)
}

func (fake *FakeParticipant) IdentityCalls(stub func() string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = stub
}

func (fake *FakeParticipant) IdentityReturns(result1 string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	fake.identityReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IdentityReturnsOnCall(i int, result1 string) {
	fake.identityMutex.Lock()
	defer fake.identityMutex.Unlock()
	fake.IdentityStub = nil
	if fake.identityReturnsOnCall == nil {
		fake.identityReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.identityReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeParticipant) IsReady() bool {
	fake.isReadyMutex.Lock()
	ret, specificReturn := fake.isReadyReturnsOnCall[len(fake.isReadyArgsForCall)]
	fake.isReadyArgsForCall = append(fake.isReadyArgsForCall, struct {
	}{})
	stub := fake.IsReadyStub
	fakeReturns := fake.isReadyReturns
	fake.recordInvocation("IsReady", []interface{}{})
	fake.isReadyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) IsReadyCallCount() int {
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	return len(fake.isReadyArgsForCall)
}

func (fake *FakeParticipant) IsReadyCalls(stub func() bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = stub
}

func (fake *FakeParticipant) IsReadyReturns(result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	fake.isReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeParticipant) IsReadyReturnsOnCall(i int, result1 bool) {
	fake.isReadyMutex.Lock()
	defer fake.isReadyMutex.Unlock()
	fake.IsReadyStub = nil
	if fake.isReadyReturnsOnCall == nil {
		fake.isReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeParticipant) OnClose(arg1 func(types.Participant)) {
	fake.onCloseMutex.Lock()
	fake.onCloseArgsForCall = append(fake.onCloseArgsForCall, struct {
		arg1 func(types.Participant)
	}{arg1})
	stub := fake.OnCloseStub
	fake.recordInvocation("OnClose", []interface{}{arg1})
	fake.onCloseMutex.Unlock()
	if stub != nil {
		fake.OnCloseStub(arg1)
	}
}

func (fake *FakeParticipant) OnCloseCallCount() int {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	return len(fake.onCloseArgsForCall)
}

func (fake *FakeParticipant) OnCloseCalls(stub func(func(types.Participant))) {
	fake.onCloseMutex.Lock()
	defer fake.onCloseMutex.Unlock()
	fake.OnCloseStub = stub
}

func (fake *FakeParticipant) OnCloseArgsForCall(i int) func(types.Participant) {
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	argsForCall := fake.onCloseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnICECandidate(arg1 func(c *webrtc.ICECandidateInit)) {
	fake.onICECandidateMutex.Lock()
	fake.onICECandidateArgsForCall = append(fake.onICECandidateArgsForCall, struct {
		arg1 func(c *webrtc.ICECandidateInit)
	}{arg1})
	stub := fake.OnICECandidateStub
	fake.recordInvocation("OnICECandidate", []interface{}{arg1})
	fake.onICECandidateMutex.Unlock()
	if stub != nil {
		fake.OnICECandidateStub(arg1)
	}
}

func (fake *FakeParticipant) OnICECandidateCallCount() int {
	fake.onICECandidateMutex.RLock()
	defer fake.onICECandidateMutex.RUnlock()
	return len(fake.onICECandidateArgsForCall)
}

func (fake *FakeParticipant) OnICECandidateCalls(stub func(func(c *webrtc.ICECandidateInit))) {
	fake.onICECandidateMutex.Lock()
	defer fake.onICECandidateMutex.Unlock()
	fake.OnICECandidateStub = stub
}

func (fake *FakeParticipant) OnICECandidateArgsForCall(i int) func(c *webrtc.ICECandidateInit) {
	fake.onICECandidateMutex.RLock()
	defer fake.onICECandidateMutex.RUnlock()
	argsForCall := fake.onICECandidateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnStateChange(arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)) {
	fake.onStateChangeMutex.Lock()
	fake.onStateChangeArgsForCall = append(fake.onStateChangeArgsForCall, struct {
		arg1 func(p types.Participant, oldState livekit.ParticipantInfo_State)
	}{arg1})
	stub := fake.OnStateChangeStub
	fake.recordInvocation("OnStateChange", []interface{}{arg1})
	fake.onStateChangeMutex.Unlock()
	if stub != nil {
		fake.OnStateChangeStub(arg1)
	}
}

func (fake *FakeParticipant) OnStateChangeCallCount() int {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	return len(fake.onStateChangeArgsForCall)
}

func (fake *FakeParticipant) OnStateChangeCalls(stub func(func(p types.Participant, oldState livekit.ParticipantInfo_State))) {
	fake.onStateChangeMutex.Lock()
	defer fake.onStateChangeMutex.Unlock()
	fake.OnStateChangeStub = stub
}

func (fake *FakeParticipant) OnStateChangeArgsForCall(i int) func(p types.Participant, oldState livekit.ParticipantInfo_State) {
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	argsForCall := fake.onStateChangeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnTrackPublished(arg1 func(types.Participant, types.PublishedTrack)) {
	fake.onTrackPublishedMutex.Lock()
	fake.onTrackPublishedArgsForCall = append(fake.onTrackPublishedArgsForCall, struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}{arg1})
	stub := fake.OnTrackPublishedStub
	fake.recordInvocation("OnTrackPublished", []interface{}{arg1})
	fake.onTrackPublishedMutex.Unlock()
	if stub != nil {
		fake.OnTrackPublishedStub(arg1)
	}
}

func (fake *FakeParticipant) OnTrackPublishedCallCount() int {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	return len(fake.onTrackPublishedArgsForCall)
}

func (fake *FakeParticipant) OnTrackPublishedCalls(stub func(func(types.Participant, types.PublishedTrack))) {
	fake.onTrackPublishedMutex.Lock()
	defer fake.onTrackPublishedMutex.Unlock()
	fake.OnTrackPublishedStub = stub
}

func (fake *FakeParticipant) OnTrackPublishedArgsForCall(i int) func(types.Participant, types.PublishedTrack) {
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	argsForCall := fake.onTrackPublishedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) OnTrackUpdated(arg1 func(types.Participant, types.PublishedTrack)) {
	fake.onTrackUpdatedMutex.Lock()
	fake.onTrackUpdatedArgsForCall = append(fake.onTrackUpdatedArgsForCall, struct {
		arg1 func(types.Participant, types.PublishedTrack)
	}{arg1})
	stub := fake.OnTrackUpdatedStub
	fake.recordInvocation("OnTrackUpdated", []interface{}{arg1})
	fake.onTrackUpdatedMutex.Unlock()
	if stub != nil {
		fake.OnTrackUpdatedStub(arg1)
	}
}

func (fake *FakeParticipant) OnTrackUpdatedCallCount() int {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	return len(fake.onTrackUpdatedArgsForCall)
}

func (fake *FakeParticipant) OnTrackUpdatedCalls(stub func(func(types.Participant, types.PublishedTrack))) {
	fake.onTrackUpdatedMutex.Lock()
	defer fake.onTrackUpdatedMutex.Unlock()
	fake.OnTrackUpdatedStub = stub
}

func (fake *FakeParticipant) OnTrackUpdatedArgsForCall(i int) func(types.Participant, types.PublishedTrack) {
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	argsForCall := fake.onTrackUpdatedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) PeerConnection() types.PeerConnection {
	fake.peerConnectionMutex.Lock()
	ret, specificReturn := fake.peerConnectionReturnsOnCall[len(fake.peerConnectionArgsForCall)]
	fake.peerConnectionArgsForCall = append(fake.peerConnectionArgsForCall, struct {
	}{})
	stub := fake.PeerConnectionStub
	fakeReturns := fake.peerConnectionReturns
	fake.recordInvocation("PeerConnection", []interface{}{})
	fake.peerConnectionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) PeerConnectionCallCount() int {
	fake.peerConnectionMutex.RLock()
	defer fake.peerConnectionMutex.RUnlock()
	return len(fake.peerConnectionArgsForCall)
}

func (fake *FakeParticipant) PeerConnectionCalls(stub func() types.PeerConnection) {
	fake.peerConnectionMutex.Lock()
	defer fake.peerConnectionMutex.Unlock()
	fake.PeerConnectionStub = stub
}

func (fake *FakeParticipant) PeerConnectionReturns(result1 types.PeerConnection) {
	fake.peerConnectionMutex.Lock()
	defer fake.peerConnectionMutex.Unlock()
	fake.PeerConnectionStub = nil
	fake.peerConnectionReturns = struct {
		result1 types.PeerConnection
	}{result1}
}

func (fake *FakeParticipant) PeerConnectionReturnsOnCall(i int, result1 types.PeerConnection) {
	fake.peerConnectionMutex.Lock()
	defer fake.peerConnectionMutex.Unlock()
	fake.PeerConnectionStub = nil
	if fake.peerConnectionReturnsOnCall == nil {
		fake.peerConnectionReturnsOnCall = make(map[int]struct {
			result1 types.PeerConnection
		})
	}
	fake.peerConnectionReturnsOnCall[i] = struct {
		result1 types.PeerConnection
	}{result1}
}

func (fake *FakeParticipant) RTCPChan() chan []rtcp.Packet {
	fake.rTCPChanMutex.Lock()
	ret, specificReturn := fake.rTCPChanReturnsOnCall[len(fake.rTCPChanArgsForCall)]
	fake.rTCPChanArgsForCall = append(fake.rTCPChanArgsForCall, struct {
	}{})
	stub := fake.RTCPChanStub
	fakeReturns := fake.rTCPChanReturns
	fake.recordInvocation("RTCPChan", []interface{}{})
	fake.rTCPChanMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) RTCPChanCallCount() int {
	fake.rTCPChanMutex.RLock()
	defer fake.rTCPChanMutex.RUnlock()
	return len(fake.rTCPChanArgsForCall)
}

func (fake *FakeParticipant) RTCPChanCalls(stub func() chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = stub
}

func (fake *FakeParticipant) RTCPChanReturns(result1 chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = nil
	fake.rTCPChanReturns = struct {
		result1 chan []rtcp.Packet
	}{result1}
}

func (fake *FakeParticipant) RTCPChanReturnsOnCall(i int, result1 chan []rtcp.Packet) {
	fake.rTCPChanMutex.Lock()
	defer fake.rTCPChanMutex.Unlock()
	fake.RTCPChanStub = nil
	if fake.rTCPChanReturnsOnCall == nil {
		fake.rTCPChanReturnsOnCall = make(map[int]struct {
			result1 chan []rtcp.Packet
		})
	}
	fake.rTCPChanReturnsOnCall[i] = struct {
		result1 chan []rtcp.Packet
	}{result1}
}

func (fake *FakeParticipant) RemoveSubscribedTrack(arg1 string, arg2 types.SubscribedTrack) {
	fake.removeSubscribedTrackMutex.Lock()
	fake.removeSubscribedTrackArgsForCall = append(fake.removeSubscribedTrackArgsForCall, struct {
		arg1 string
		arg2 types.SubscribedTrack
	}{arg1, arg2})
	stub := fake.RemoveSubscribedTrackStub
	fake.recordInvocation("RemoveSubscribedTrack", []interface{}{arg1, arg2})
	fake.removeSubscribedTrackMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscribedTrackStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) RemoveSubscribedTrackCallCount() int {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	return len(fake.removeSubscribedTrackArgsForCall)
}

func (fake *FakeParticipant) RemoveSubscribedTrackCalls(stub func(string, types.SubscribedTrack)) {
	fake.removeSubscribedTrackMutex.Lock()
	defer fake.removeSubscribedTrackMutex.Unlock()
	fake.RemoveSubscribedTrackStub = stub
}

func (fake *FakeParticipant) RemoveSubscribedTrackArgsForCall(i int) (string, types.SubscribedTrack) {
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	argsForCall := fake.removeSubscribedTrackArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) RemoveSubscriber(arg1 string) {
	fake.removeSubscriberMutex.Lock()
	fake.removeSubscriberArgsForCall = append(fake.removeSubscriberArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveSubscriberStub
	fake.recordInvocation("RemoveSubscriber", []interface{}{arg1})
	fake.removeSubscriberMutex.Unlock()
	if stub != nil {
		fake.RemoveSubscriberStub(arg1)
	}
}

func (fake *FakeParticipant) RemoveSubscriberCallCount() int {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	return len(fake.removeSubscriberArgsForCall)
}

func (fake *FakeParticipant) RemoveSubscriberCalls(stub func(string)) {
	fake.removeSubscriberMutex.Lock()
	defer fake.removeSubscriberMutex.Unlock()
	fake.RemoveSubscriberStub = stub
}

func (fake *FakeParticipant) RemoveSubscriberArgsForCall(i int) string {
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	argsForCall := fake.removeSubscriberArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SendJoinResponse(arg1 *livekit.Room, arg2 []types.Participant) error {
	var arg2Copy []types.Participant
	if arg2 != nil {
		arg2Copy = make([]types.Participant, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sendJoinResponseMutex.Lock()
	ret, specificReturn := fake.sendJoinResponseReturnsOnCall[len(fake.sendJoinResponseArgsForCall)]
	fake.sendJoinResponseArgsForCall = append(fake.sendJoinResponseArgsForCall, struct {
		arg1 *livekit.Room
		arg2 []types.Participant
	}{arg1, arg2Copy})
	stub := fake.SendJoinResponseStub
	fakeReturns := fake.sendJoinResponseReturns
	fake.recordInvocation("SendJoinResponse", []interface{}{arg1, arg2Copy})
	fake.sendJoinResponseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SendJoinResponseCallCount() int {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	return len(fake.sendJoinResponseArgsForCall)
}

func (fake *FakeParticipant) SendJoinResponseCalls(stub func(*livekit.Room, []types.Participant) error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = stub
}

func (fake *FakeParticipant) SendJoinResponseArgsForCall(i int) (*livekit.Room, []types.Participant) {
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	argsForCall := fake.sendJoinResponseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) SendJoinResponseReturns(result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	fake.sendJoinResponseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendJoinResponseReturnsOnCall(i int, result1 error) {
	fake.sendJoinResponseMutex.Lock()
	defer fake.sendJoinResponseMutex.Unlock()
	fake.SendJoinResponseStub = nil
	if fake.sendJoinResponseReturnsOnCall == nil {
		fake.sendJoinResponseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendJoinResponseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendParticipantUpdate(arg1 []*livekit.ParticipantInfo) error {
	var arg1Copy []*livekit.ParticipantInfo
	if arg1 != nil {
		arg1Copy = make([]*livekit.ParticipantInfo, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.sendParticipantUpdateMutex.Lock()
	ret, specificReturn := fake.sendParticipantUpdateReturnsOnCall[len(fake.sendParticipantUpdateArgsForCall)]
	fake.sendParticipantUpdateArgsForCall = append(fake.sendParticipantUpdateArgsForCall, struct {
		arg1 []*livekit.ParticipantInfo
	}{arg1Copy})
	stub := fake.SendParticipantUpdateStub
	fakeReturns := fake.sendParticipantUpdateReturns
	fake.recordInvocation("SendParticipantUpdate", []interface{}{arg1Copy})
	fake.sendParticipantUpdateMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SendParticipantUpdateCallCount() int {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	return len(fake.sendParticipantUpdateArgsForCall)
}

func (fake *FakeParticipant) SendParticipantUpdateCalls(stub func([]*livekit.ParticipantInfo) error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = stub
}

func (fake *FakeParticipant) SendParticipantUpdateArgsForCall(i int) []*livekit.ParticipantInfo {
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	argsForCall := fake.sendParticipantUpdateArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SendParticipantUpdateReturns(result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	fake.sendParticipantUpdateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SendParticipantUpdateReturnsOnCall(i int, result1 error) {
	fake.sendParticipantUpdateMutex.Lock()
	defer fake.sendParticipantUpdateMutex.Unlock()
	fake.SendParticipantUpdateStub = nil
	if fake.sendParticipantUpdateReturnsOnCall == nil {
		fake.sendParticipantUpdateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendParticipantUpdateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetMetadata(arg1 map[string]interface{}) error {
	fake.setMetadataMutex.Lock()
	ret, specificReturn := fake.setMetadataReturnsOnCall[len(fake.setMetadataArgsForCall)]
	fake.setMetadataArgsForCall = append(fake.setMetadataArgsForCall, struct {
		arg1 map[string]interface{}
	}{arg1})
	stub := fake.SetMetadataStub
	fakeReturns := fake.setMetadataReturns
	fake.recordInvocation("SetMetadata", []interface{}{arg1})
	fake.setMetadataMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) SetMetadataCallCount() int {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	return len(fake.setMetadataArgsForCall)
}

func (fake *FakeParticipant) SetMetadataCalls(stub func(map[string]interface{}) error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = stub
}

func (fake *FakeParticipant) SetMetadataArgsForCall(i int) map[string]interface{} {
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	argsForCall := fake.setMetadataArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SetMetadataReturns(result1 error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = nil
	fake.setMetadataReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetMetadataReturnsOnCall(i int, result1 error) {
	fake.setMetadataMutex.Lock()
	defer fake.setMetadataMutex.Unlock()
	fake.SetMetadataStub = nil
	if fake.setMetadataReturnsOnCall == nil {
		fake.setMetadataReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setMetadataReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeParticipant) SetResponseSink(arg1 routing.MessageSink) {
	fake.setResponseSinkMutex.Lock()
	fake.setResponseSinkArgsForCall = append(fake.setResponseSinkArgsForCall, struct {
		arg1 routing.MessageSink
	}{arg1})
	stub := fake.SetResponseSinkStub
	fake.recordInvocation("SetResponseSink", []interface{}{arg1})
	fake.setResponseSinkMutex.Unlock()
	if stub != nil {
		fake.SetResponseSinkStub(arg1)
	}
}

func (fake *FakeParticipant) SetResponseSinkCallCount() int {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	return len(fake.setResponseSinkArgsForCall)
}

func (fake *FakeParticipant) SetResponseSinkCalls(stub func(routing.MessageSink)) {
	fake.setResponseSinkMutex.Lock()
	defer fake.setResponseSinkMutex.Unlock()
	fake.SetResponseSinkStub = stub
}

func (fake *FakeParticipant) SetResponseSinkArgsForCall(i int) routing.MessageSink {
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	argsForCall := fake.setResponseSinkArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeParticipant) SetTrackMuted(arg1 string, arg2 bool) {
	fake.setTrackMutedMutex.Lock()
	fake.setTrackMutedArgsForCall = append(fake.setTrackMutedArgsForCall, struct {
		arg1 string
		arg2 bool
	}{arg1, arg2})
	stub := fake.SetTrackMutedStub
	fake.recordInvocation("SetTrackMuted", []interface{}{arg1, arg2})
	fake.setTrackMutedMutex.Unlock()
	if stub != nil {
		fake.SetTrackMutedStub(arg1, arg2)
	}
}

func (fake *FakeParticipant) SetTrackMutedCallCount() int {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	return len(fake.setTrackMutedArgsForCall)
}

func (fake *FakeParticipant) SetTrackMutedCalls(stub func(string, bool)) {
	fake.setTrackMutedMutex.Lock()
	defer fake.setTrackMutedMutex.Unlock()
	fake.SetTrackMutedStub = stub
}

func (fake *FakeParticipant) SetTrackMutedArgsForCall(i int) (string, bool) {
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	argsForCall := fake.setTrackMutedArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeParticipant) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	stub := fake.StartStub
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if stub != nil {
		fake.StartStub()
	}
}

func (fake *FakeParticipant) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeParticipant) StartCalls(stub func()) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeParticipant) State() livekit.ParticipantInfo_State {
	fake.stateMutex.Lock()
	ret, specificReturn := fake.stateReturnsOnCall[len(fake.stateArgsForCall)]
	fake.stateArgsForCall = append(fake.stateArgsForCall, struct {
	}{})
	stub := fake.StateStub
	fakeReturns := fake.stateReturns
	fake.recordInvocation("State", []interface{}{})
	fake.stateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) StateCallCount() int {
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	return len(fake.stateArgsForCall)
}

func (fake *FakeParticipant) StateCalls(stub func() livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = stub
}

func (fake *FakeParticipant) StateReturns(result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	fake.stateReturns = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeParticipant) StateReturnsOnCall(i int, result1 livekit.ParticipantInfo_State) {
	fake.stateMutex.Lock()
	defer fake.stateMutex.Unlock()
	fake.StateStub = nil
	if fake.stateReturnsOnCall == nil {
		fake.stateReturnsOnCall = make(map[int]struct {
			result1 livekit.ParticipantInfo_State
		})
	}
	fake.stateReturnsOnCall[i] = struct {
		result1 livekit.ParticipantInfo_State
	}{result1}
}

func (fake *FakeParticipant) ToProto() *livekit.ParticipantInfo {
	fake.toProtoMutex.Lock()
	ret, specificReturn := fake.toProtoReturnsOnCall[len(fake.toProtoArgsForCall)]
	fake.toProtoArgsForCall = append(fake.toProtoArgsForCall, struct {
	}{})
	stub := fake.ToProtoStub
	fakeReturns := fake.toProtoReturns
	fake.recordInvocation("ToProto", []interface{}{})
	fake.toProtoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeParticipant) ToProtoCallCount() int {
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	return len(fake.toProtoArgsForCall)
}

func (fake *FakeParticipant) ToProtoCalls(stub func() *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = stub
}

func (fake *FakeParticipant) ToProtoReturns(result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	fake.toProtoReturns = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeParticipant) ToProtoReturnsOnCall(i int, result1 *livekit.ParticipantInfo) {
	fake.toProtoMutex.Lock()
	defer fake.toProtoMutex.Unlock()
	fake.ToProtoStub = nil
	if fake.toProtoReturnsOnCall == nil {
		fake.toProtoReturnsOnCall = make(map[int]struct {
			result1 *livekit.ParticipantInfo
		})
	}
	fake.toProtoReturnsOnCall[i] = struct {
		result1 *livekit.ParticipantInfo
	}{result1}
}

func (fake *FakeParticipant) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addICECandidateMutex.RLock()
	defer fake.addICECandidateMutex.RUnlock()
	fake.addSubscribedTrackMutex.RLock()
	defer fake.addSubscribedTrackMutex.RUnlock()
	fake.addSubscriberMutex.RLock()
	defer fake.addSubscriberMutex.RUnlock()
	fake.addTrackMutex.RLock()
	defer fake.addTrackMutex.RUnlock()
	fake.answerMutex.RLock()
	defer fake.answerMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.getResponseSinkMutex.RLock()
	defer fake.getResponseSinkMutex.RUnlock()
	fake.handleAnswerMutex.RLock()
	defer fake.handleAnswerMutex.RUnlock()
	fake.handleClientNegotiationMutex.RLock()
	defer fake.handleClientNegotiationMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.identityMutex.RLock()
	defer fake.identityMutex.RUnlock()
	fake.isReadyMutex.RLock()
	defer fake.isReadyMutex.RUnlock()
	fake.onCloseMutex.RLock()
	defer fake.onCloseMutex.RUnlock()
	fake.onICECandidateMutex.RLock()
	defer fake.onICECandidateMutex.RUnlock()
	fake.onStateChangeMutex.RLock()
	defer fake.onStateChangeMutex.RUnlock()
	fake.onTrackPublishedMutex.RLock()
	defer fake.onTrackPublishedMutex.RUnlock()
	fake.onTrackUpdatedMutex.RLock()
	defer fake.onTrackUpdatedMutex.RUnlock()
	fake.peerConnectionMutex.RLock()
	defer fake.peerConnectionMutex.RUnlock()
	fake.rTCPChanMutex.RLock()
	defer fake.rTCPChanMutex.RUnlock()
	fake.removeSubscribedTrackMutex.RLock()
	defer fake.removeSubscribedTrackMutex.RUnlock()
	fake.removeSubscriberMutex.RLock()
	defer fake.removeSubscriberMutex.RUnlock()
	fake.sendJoinResponseMutex.RLock()
	defer fake.sendJoinResponseMutex.RUnlock()
	fake.sendParticipantUpdateMutex.RLock()
	defer fake.sendParticipantUpdateMutex.RUnlock()
	fake.setMetadataMutex.RLock()
	defer fake.setMetadataMutex.RUnlock()
	fake.setResponseSinkMutex.RLock()
	defer fake.setResponseSinkMutex.RUnlock()
	fake.setTrackMutedMutex.RLock()
	defer fake.setTrackMutedMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	fake.stateMutex.RLock()
	defer fake.stateMutex.RUnlock()
	fake.toProtoMutex.RLock()
	defer fake.toProtoMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeParticipant) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ types.Participant = new(FakeParticipant)
