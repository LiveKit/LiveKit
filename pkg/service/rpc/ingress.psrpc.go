// Code generated by protoc-gen-psrpc v0.2.2, DO NOT EDIT.
// source: pkg/service/rpc/ingress.proto

package rpc

import context "context"

import psrpc1 "github.com/livekit/psrpc"
import livekit3 "github.com/livekit/protocol/livekit"

// ================================
// IngressInternal Client Interface
// ================================

type IngressInternalClient interface {
	ListActiveIngress(context.Context, *ListActiveIngressRequest, ...psrpc1.RequestOption) (<-chan *psrpc1.Response[*ListActiveIngressResponse], error)
}

// ====================================
// IngressInternal ServerImpl Interface
// ====================================

type IngressInternalServerImpl interface {
	ListActiveIngress(context.Context, *ListActiveIngressRequest) (*ListActiveIngressResponse, error)
}

// ================================
// IngressInternal Server Interface
// ================================

type IngressInternalServer interface {
	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ======================
// IngressInternal Client
// ======================

type ingressInternalClient struct {
	client *psrpc1.RPCClient
}

// NewIngressInternalClient creates a psrpc client that implements the IngressInternalClient interface.
func NewIngressInternalClient(clientID string, bus psrpc1.MessageBus, opts ...psrpc1.ClientOption) (IngressInternalClient, error) {
	rpcClient, err := psrpc1.NewRPCClient("IngressInternal", clientID, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressInternalClient{
		client: rpcClient,
	}, nil
}

func (c *ingressInternalClient) ListActiveIngress(ctx context.Context, req *ListActiveIngressRequest, opts ...psrpc1.RequestOption) (<-chan *psrpc1.Response[*ListActiveIngressResponse], error) {
	return psrpc1.RequestMulti[*ListActiveIngressResponse](ctx, c.client, "ListActiveIngress", "", req, opts...)
}

// ======================
// IngressInternal Server
// ======================

type ingressInternalServer struct {
	svc IngressInternalServerImpl
	rpc *psrpc1.RPCServer
}

// NewIngressInternalServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressInternalServer(serverID string, svc IngressInternalServerImpl, bus psrpc1.MessageBus, opts ...psrpc1.ServerOption) (IngressInternalServer, error) {
	s := psrpc1.NewRPCServer("IngressInternal", serverID, bus, opts...)

	var err error
	err = psrpc1.RegisterHandler(s, "ListActiveIngress", "", svc.ListActiveIngress, nil)
	if err != nil {
		s.Close(false)
		return nil, err
	}

	return &ingressInternalServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressInternalServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressInternalServer) Kill() {
	s.rpc.Close(true)
}

// ==============================
// IngressEntity Client Interface
// ==============================

type IngressEntityClient interface {
	GetIngressInfo(context.Context, *livekit3.GetIngressInfoRequest, ...psrpc1.RequestOption) (*livekit3.GetIngressInfoResponse, error)
}

// ==================================
// IngressEntity ServerImpl Interface
// ==================================

type IngressEntityServerImpl interface {
	GetIngressInfo(context.Context, *livekit3.GetIngressInfoRequest) (*livekit3.GetIngressInfoResponse, error)
}

// ==============================
// IngressEntity Server Interface
// ==============================

type IngressEntityServer interface {
	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ====================
// IngressEntity Client
// ====================

type ingressEntityClient struct {
	client *psrpc1.RPCClient
}

// NewIngressEntityClient creates a psrpc client that implements the IngressEntityClient interface.
func NewIngressEntityClient(clientID string, bus psrpc1.MessageBus, opts ...psrpc1.ClientOption) (IngressEntityClient, error) {
	rpcClient, err := psrpc1.NewRPCClient("IngressEntity", clientID, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressEntityClient{
		client: rpcClient,
	}, nil
}

func (c *ingressEntityClient) GetIngressInfo(ctx context.Context, req *livekit3.GetIngressInfoRequest, opts ...psrpc1.RequestOption) (*livekit3.GetIngressInfoResponse, error) {
	return psrpc1.RequestSingle[*livekit3.GetIngressInfoResponse](ctx, c.client, "GetIngressInfo", "", req, opts...)
}

// ====================
// IngressEntity Server
// ====================

type ingressEntityServer struct {
	svc IngressEntityServerImpl
	rpc *psrpc1.RPCServer
}

// NewIngressEntityServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressEntityServer(serverID string, svc IngressEntityServerImpl, bus psrpc1.MessageBus, opts ...psrpc1.ServerOption) (IngressEntityServer, error) {
	s := psrpc1.NewRPCServer("IngressEntity", serverID, bus, opts...)

	var err error
	err = psrpc1.RegisterHandler(s, "GetIngressInfo", "", svc.GetIngressInfo, nil)
	if err != nil {
		s.Close(false)
		return nil, err
	}

	return &ingressEntityServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressEntityServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressEntityServer) Kill() {
	s.rpc.Close(true)
}

// ===============================
// IngressHandler Client Interface
// ===============================

type IngressHandlerClient interface {
	HangUpIngress(context.Context, string, *HangUpIngressRequest, ...psrpc1.RequestOption) (*HangUpIngressResponse, error)
}

// ===================================
// IngressHandler ServerImpl Interface
// ===================================

type IngressHandlerServerImpl interface {
	HangUpIngress(context.Context, *HangUpIngressRequest) (*HangUpIngressResponse, error)
}

// ===============================
// IngressHandler Server Interface
// ===============================

type IngressHandlerServer interface {
	RegisterHangUpIngressTopic(string) error
	DeregisterHangUpIngressTopic(string)

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// =====================
// IngressHandler Client
// =====================

type ingressHandlerClient struct {
	client *psrpc1.RPCClient
}

// NewIngressHandlerClient creates a psrpc client that implements the IngressHandlerClient interface.
func NewIngressHandlerClient(clientID string, bus psrpc1.MessageBus, opts ...psrpc1.ClientOption) (IngressHandlerClient, error) {
	rpcClient, err := psrpc1.NewRPCClient("IngressHandler", clientID, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressHandlerClient{
		client: rpcClient,
	}, nil
}

func (c *ingressHandlerClient) HangUpIngress(ctx context.Context, topic string, req *HangUpIngressRequest, opts ...psrpc1.RequestOption) (*HangUpIngressResponse, error) {
	return psrpc1.RequestSingle[*HangUpIngressResponse](ctx, c.client, "HangUpIngress", topic, req, opts...)
}

// =====================
// IngressHandler Server
// =====================

type ingressHandlerServer struct {
	svc IngressHandlerServerImpl
	rpc *psrpc1.RPCServer
}

// NewIngressHandlerServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressHandlerServer(serverID string, svc IngressHandlerServerImpl, bus psrpc1.MessageBus, opts ...psrpc1.ServerOption) (IngressHandlerServer, error) {
	s := psrpc1.NewRPCServer("IngressHandler", serverID, bus, opts...)

	return &ingressHandlerServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressHandlerServer) RegisterHangUpIngressTopic(topic string) error {
	return psrpc1.RegisterHandler(s.rpc, "HangUpIngress", topic, s.svc.HangUpIngress, nil)
}

func (s *ingressHandlerServer) DeregisterHangUpIngressTopic(topic string) {
	s.rpc.DeregisterHandler("HangUpIngress", topic)
}

func (s *ingressHandlerServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressHandlerServer) Kill() {
	s.rpc.Close(true)
}

// ==============================
// IngressUpdate Client Interface
// ==============================

type IngressUpdateClient interface {
	SubscribeStateUpdate(context.Context) (psrpc1.Subscription[*livekit3.UpdateIngressStateRequest], error)
}

// ==================================
// IngressUpdate ServerImpl Interface
// ==================================

type IngressUpdateServerImpl interface {
}

// ==============================
// IngressUpdate Server Interface
// ==============================

type IngressUpdateServer interface {
	PublishStateUpdate(context.Context, *livekit3.UpdateIngressStateRequest) error

	// Close and wait for pending RPCs to complete
	Shutdown()

	// Close immediately, without waiting for pending RPCs
	Kill()
}

// ====================
// IngressUpdate Client
// ====================

type ingressUpdateClient struct {
	client *psrpc1.RPCClient
}

// NewIngressUpdateClient creates a psrpc client that implements the IngressUpdateClient interface.
func NewIngressUpdateClient(clientID string, bus psrpc1.MessageBus, opts ...psrpc1.ClientOption) (IngressUpdateClient, error) {
	rpcClient, err := psrpc1.NewRPCClient("IngressUpdate", clientID, bus, opts...)
	if err != nil {
		return nil, err
	}

	return &ingressUpdateClient{
		client: rpcClient,
	}, nil
}

func (c *ingressUpdateClient) SubscribeStateUpdate(ctx context.Context) (psrpc1.Subscription[*livekit3.UpdateIngressStateRequest], error) {
	return psrpc1.JoinQueue[*livekit3.UpdateIngressStateRequest](ctx, c.client, "StateUpdate", "")
}

// ====================
// IngressUpdate Server
// ====================

type ingressUpdateServer struct {
	svc IngressUpdateServerImpl
	rpc *psrpc1.RPCServer
}

// NewIngressUpdateServer builds a RPCServer that will route requests
// to the corresponding method in the provided svc implementation.
func NewIngressUpdateServer(serverID string, svc IngressUpdateServerImpl, bus psrpc1.MessageBus, opts ...psrpc1.ServerOption) (IngressUpdateServer, error) {
	s := psrpc1.NewRPCServer("IngressUpdate", serverID, bus, opts...)

	return &ingressUpdateServer{
		svc: svc,
		rpc: s,
	}, nil
}

func (s *ingressUpdateServer) PublishStateUpdate(ctx context.Context, msg *livekit3.UpdateIngressStateRequest) error {
	return s.rpc.Publish(ctx, "StateUpdate", "", msg)
}

func (s *ingressUpdateServer) Shutdown() {
	s.rpc.Close(false)
}

func (s *ingressUpdateServer) Kill() {
	s.rpc.Close(true)
}

var psrpcFileDescriptor1 = []byte{
	// 353 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x92, 0x51, 0x4b, 0x2a, 0x41,
	0x1c, 0xc5, 0xd9, 0x2b, 0x78, 0xaf, 0x7f, 0xaf, 0x56, 0x43, 0x96, 0x0e, 0xa8, 0xb1, 0x4f, 0x11,
	0xb1, 0x0b, 0xf6, 0xda, 0x4b, 0x41, 0xe8, 0x42, 0x04, 0x19, 0x42, 0xf8, 0x62, 0xeb, 0xec, 0xb4,
	0x0d, 0xea, 0xcc, 0x34, 0x33, 0x0a, 0x7d, 0x84, 0xbe, 0x4e, 0x9f, 0x30, 0xd8, 0xfd, 0xbb, 0xa4,
	0xe9, 0xd3, 0xb2, 0xe7, 0x37, 0xff, 0x33, 0xe7, 0xcc, 0x0c, 0xb4, 0xf5, 0x2c, 0x0d, 0x2d, 0x37,
	0x2b, 0xc1, 0x78, 0x68, 0x34, 0x0b, 0x85, 0x4c, 0x0d, 0xb7, 0x36, 0xd0, 0x46, 0x39, 0x45, 0x4a,
	0x46, 0x33, 0x5a, 0x53, 0xda, 0x09, 0x25, 0x51, 0xa3, 0x74, 0x2e, 0x56, 0x7c, 0x26, 0xdc, 0xc4,
	0x68, 0x36, 0x11, 0xd2, 0x71, 0x23, 0xe3, 0x39, 0xb2, 0xc6, 0x9a, 0x6d, 0xd8, 0xf8, 0x15, 0xf8,
	0x1b, 0xa5, 0x52, 0x19, 0x9e, 0xf8, 0x14, 0x9a, 0xf7, 0xc2, 0xba, 0x1b, 0xe6, 0xc4, 0x8a, 0x47,
	0xf9, 0xaa, 0x21, 0x7f, 0x5f, 0x72, 0xeb, 0xfc, 0x6b, 0x68, 0xed, 0x60, 0x56, 0x2b, 0x69, 0x39,
	0xe9, 0x42, 0x15, 0x4d, 0x27, 0x22, 0xb1, 0x4d, 0xef, 0xac, 0x74, 0x5e, 0x19, 0x02, 0x4a, 0x51,
	0x62, 0xfd, 0x13, 0x38, 0x1e, 0xc4, 0x32, 0x1d, 0xe9, 0x2d, 0xd7, 0x53, 0x68, 0x6c, 0xe9, 0xb9,
	0x63, 0x6f, 0x01, 0x07, 0x28, 0x45, 0xd8, 0x82, 0x8c, 0xe1, 0xe8, 0x57, 0x02, 0xd2, 0x0e, 0x8c,
	0x66, 0xc1, 0xbe, 0xd4, 0xb4, 0xb3, 0x0f, 0xe7, 0xdb, 0xf8, 0xe5, 0xaf, 0x4f, 0xef, 0xcf, 0x3f,
	0xaf, 0x37, 0x85, 0x1a, 0xa2, 0x3b, 0xe9, 0x84, 0xfb, 0x20, 0x8f, 0x50, 0xef, 0x73, 0x57, 0x44,
	0x78, 0x55, 0xa4, 0x13, 0xe0, 0xf9, 0x05, 0x9b, 0x60, 0xbd, 0x55, 0x77, 0x2f, 0xc7, 0x4a, 0x2f,
	0x50, 0x47, 0x79, 0x10, 0xcb, 0x64, 0xce, 0x0d, 0x79, 0x80, 0xda, 0x46, 0x7b, 0xd2, 0xca, 0xe2,
	0xee, 0x3a, 0x29, 0x4a, 0x77, 0xa1, 0x9f, 0x2d, 0x9a, 0x5e, 0xef, 0xb9, 0x68, 0x31, 0xd2, 0x49,
	0xec, 0x38, 0xe9, 0x43, 0xf5, 0xc9, 0xc5, 0x8e, 0xe3, 0xef, 0xff, 0xcc, 0x03, 0x6f, 0x9b, 0xfa,
	0x45, 0xe0, 0x1c, 0xe3, 0x68, 0x36, 0xb0, 0xbe, 0x9f, 0xcc, 0xf9, 0xd0, 0xbb, 0xbd, 0x1c, 0x5f,
	0xa4, 0xc2, 0xbd, 0x2d, 0xa7, 0x01, 0x53, 0x8b, 0x10, 0xe7, 0x8a, 0xef, 0xd6, 0x3b, 0x9d, 0x96,
	0xb3, 0x97, 0x75, 0xf5, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x1c, 0xe1, 0xa0, 0xa4, 0xc1, 0x02, 0x00,
	0x00,
}
