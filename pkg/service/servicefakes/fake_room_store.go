// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"sync"
	"time"

	"github.com/livekit/livekit-server/pkg/service"
	livekit "github.com/livekit/protocol/proto"
)

type FakeRoomStore struct {
	DeleteParticipantStub        func(string, string) error
	deleteParticipantMutex       sync.RWMutex
	deleteParticipantArgsForCall []struct {
		arg1 string
		arg2 string
	}
	deleteParticipantReturns struct {
		result1 error
	}
	deleteParticipantReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteRoomStub        func(string) error
	deleteRoomMutex       sync.RWMutex
	deleteRoomArgsForCall []struct {
		arg1 string
	}
	deleteRoomReturns struct {
		result1 error
	}
	deleteRoomReturnsOnCall map[int]struct {
		result1 error
	}
	GetParticipantStub        func(string, string) (*livekit.ParticipantInfo, error)
	getParticipantMutex       sync.RWMutex
	getParticipantArgsForCall []struct {
		arg1 string
		arg2 string
	}
	getParticipantReturns struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}
	getParticipantReturnsOnCall map[int]struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}
	ListParticipantsStub        func(string) ([]*livekit.ParticipantInfo, error)
	listParticipantsMutex       sync.RWMutex
	listParticipantsArgsForCall []struct {
		arg1 string
	}
	listParticipantsReturns struct {
		result1 []*livekit.ParticipantInfo
		result2 error
	}
	listParticipantsReturnsOnCall map[int]struct {
		result1 []*livekit.ParticipantInfo
		result2 error
	}
	ListRoomsStub        func() ([]*livekit.Room, error)
	listRoomsMutex       sync.RWMutex
	listRoomsArgsForCall []struct {
	}
	listRoomsReturns struct {
		result1 []*livekit.Room
		result2 error
	}
	listRoomsReturnsOnCall map[int]struct {
		result1 []*livekit.Room
		result2 error
	}
	LoadRoomStub        func(string) (*livekit.Room, error)
	loadRoomMutex       sync.RWMutex
	loadRoomArgsForCall []struct {
		arg1 string
	}
	loadRoomReturns struct {
		result1 *livekit.Room
		result2 error
	}
	loadRoomReturnsOnCall map[int]struct {
		result1 *livekit.Room
		result2 error
	}
	LockRoomStub        func(string, time.Duration) (string, error)
	lockRoomMutex       sync.RWMutex
	lockRoomArgsForCall []struct {
		arg1 string
		arg2 time.Duration
	}
	lockRoomReturns struct {
		result1 string
		result2 error
	}
	lockRoomReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	PersistParticipantStub        func(string, *livekit.ParticipantInfo) error
	persistParticipantMutex       sync.RWMutex
	persistParticipantArgsForCall []struct {
		arg1 string
		arg2 *livekit.ParticipantInfo
	}
	persistParticipantReturns struct {
		result1 error
	}
	persistParticipantReturnsOnCall map[int]struct {
		result1 error
	}
	StoreRoomStub        func(*livekit.Room) error
	storeRoomMutex       sync.RWMutex
	storeRoomArgsForCall []struct {
		arg1 *livekit.Room
	}
	storeRoomReturns struct {
		result1 error
	}
	storeRoomReturnsOnCall map[int]struct {
		result1 error
	}
	UnlockRoomStub        func(string, string) error
	unlockRoomMutex       sync.RWMutex
	unlockRoomArgsForCall []struct {
		arg1 string
		arg2 string
	}
	unlockRoomReturns struct {
		result1 error
	}
	unlockRoomReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRoomStore) DeleteParticipant(arg1 string, arg2 string) error {
	fake.deleteParticipantMutex.Lock()
	ret, specificReturn := fake.deleteParticipantReturnsOnCall[len(fake.deleteParticipantArgsForCall)]
	fake.deleteParticipantArgsForCall = append(fake.deleteParticipantArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteParticipantStub
	fakeReturns := fake.deleteParticipantReturns
	fake.recordInvocation("DeleteParticipant", []interface{}{arg1, arg2})
	fake.deleteParticipantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRoomStore) DeleteParticipantCallCount() int {
	fake.deleteParticipantMutex.RLock()
	defer fake.deleteParticipantMutex.RUnlock()
	return len(fake.deleteParticipantArgsForCall)
}

func (fake *FakeRoomStore) DeleteParticipantCalls(stub func(string, string) error) {
	fake.deleteParticipantMutex.Lock()
	defer fake.deleteParticipantMutex.Unlock()
	fake.DeleteParticipantStub = stub
}

func (fake *FakeRoomStore) DeleteParticipantArgsForCall(i int) (string, string) {
	fake.deleteParticipantMutex.RLock()
	defer fake.deleteParticipantMutex.RUnlock()
	argsForCall := fake.deleteParticipantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRoomStore) DeleteParticipantReturns(result1 error) {
	fake.deleteParticipantMutex.Lock()
	defer fake.deleteParticipantMutex.Unlock()
	fake.DeleteParticipantStub = nil
	fake.deleteParticipantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) DeleteParticipantReturnsOnCall(i int, result1 error) {
	fake.deleteParticipantMutex.Lock()
	defer fake.deleteParticipantMutex.Unlock()
	fake.DeleteParticipantStub = nil
	if fake.deleteParticipantReturnsOnCall == nil {
		fake.deleteParticipantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteParticipantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) DeleteRoom(arg1 string) error {
	fake.deleteRoomMutex.Lock()
	ret, specificReturn := fake.deleteRoomReturnsOnCall[len(fake.deleteRoomArgsForCall)]
	fake.deleteRoomArgsForCall = append(fake.deleteRoomArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteRoomStub
	fakeReturns := fake.deleteRoomReturns
	fake.recordInvocation("DeleteRoom", []interface{}{arg1})
	fake.deleteRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRoomStore) DeleteRoomCallCount() int {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	return len(fake.deleteRoomArgsForCall)
}

func (fake *FakeRoomStore) DeleteRoomCalls(stub func(string) error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = stub
}

func (fake *FakeRoomStore) DeleteRoomArgsForCall(i int) string {
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	argsForCall := fake.deleteRoomArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomStore) DeleteRoomReturns(result1 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	fake.deleteRoomReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) DeleteRoomReturnsOnCall(i int, result1 error) {
	fake.deleteRoomMutex.Lock()
	defer fake.deleteRoomMutex.Unlock()
	fake.DeleteRoomStub = nil
	if fake.deleteRoomReturnsOnCall == nil {
		fake.deleteRoomReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteRoomReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) LoadParticipant(arg1 string, arg2 string) (*livekit.ParticipantInfo, error) {
	fake.getParticipantMutex.Lock()
	ret, specificReturn := fake.getParticipantReturnsOnCall[len(fake.getParticipantArgsForCall)]
	fake.getParticipantArgsForCall = append(fake.getParticipantArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.GetParticipantStub
	fakeReturns := fake.getParticipantReturns
	fake.recordInvocation("LoadParticipant", []interface{}{arg1, arg2})
	fake.getParticipantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRoomStore) GetParticipantCallCount() int {
	fake.getParticipantMutex.RLock()
	defer fake.getParticipantMutex.RUnlock()
	return len(fake.getParticipantArgsForCall)
}

func (fake *FakeRoomStore) GetParticipantCalls(stub func(string, string) (*livekit.ParticipantInfo, error)) {
	fake.getParticipantMutex.Lock()
	defer fake.getParticipantMutex.Unlock()
	fake.GetParticipantStub = stub
}

func (fake *FakeRoomStore) GetParticipantArgsForCall(i int) (string, string) {
	fake.getParticipantMutex.RLock()
	defer fake.getParticipantMutex.RUnlock()
	argsForCall := fake.getParticipantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRoomStore) GetParticipantReturns(result1 *livekit.ParticipantInfo, result2 error) {
	fake.getParticipantMutex.Lock()
	defer fake.getParticipantMutex.Unlock()
	fake.GetParticipantStub = nil
	fake.getParticipantReturns = struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) GetParticipantReturnsOnCall(i int, result1 *livekit.ParticipantInfo, result2 error) {
	fake.getParticipantMutex.Lock()
	defer fake.getParticipantMutex.Unlock()
	fake.GetParticipantStub = nil
	if fake.getParticipantReturnsOnCall == nil {
		fake.getParticipantReturnsOnCall = make(map[int]struct {
			result1 *livekit.ParticipantInfo
			result2 error
		})
	}
	fake.getParticipantReturnsOnCall[i] = struct {
		result1 *livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) ListParticipants(arg1 string) ([]*livekit.ParticipantInfo, error) {
	fake.listParticipantsMutex.Lock()
	ret, specificReturn := fake.listParticipantsReturnsOnCall[len(fake.listParticipantsArgsForCall)]
	fake.listParticipantsArgsForCall = append(fake.listParticipantsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ListParticipantsStub
	fakeReturns := fake.listParticipantsReturns
	fake.recordInvocation("ListParticipants", []interface{}{arg1})
	fake.listParticipantsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRoomStore) ListParticipantsCallCount() int {
	fake.listParticipantsMutex.RLock()
	defer fake.listParticipantsMutex.RUnlock()
	return len(fake.listParticipantsArgsForCall)
}

func (fake *FakeRoomStore) ListParticipantsCalls(stub func(string) ([]*livekit.ParticipantInfo, error)) {
	fake.listParticipantsMutex.Lock()
	defer fake.listParticipantsMutex.Unlock()
	fake.ListParticipantsStub = stub
}

func (fake *FakeRoomStore) ListParticipantsArgsForCall(i int) string {
	fake.listParticipantsMutex.RLock()
	defer fake.listParticipantsMutex.RUnlock()
	argsForCall := fake.listParticipantsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomStore) ListParticipantsReturns(result1 []*livekit.ParticipantInfo, result2 error) {
	fake.listParticipantsMutex.Lock()
	defer fake.listParticipantsMutex.Unlock()
	fake.ListParticipantsStub = nil
	fake.listParticipantsReturns = struct {
		result1 []*livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) ListParticipantsReturnsOnCall(i int, result1 []*livekit.ParticipantInfo, result2 error) {
	fake.listParticipantsMutex.Lock()
	defer fake.listParticipantsMutex.Unlock()
	fake.ListParticipantsStub = nil
	if fake.listParticipantsReturnsOnCall == nil {
		fake.listParticipantsReturnsOnCall = make(map[int]struct {
			result1 []*livekit.ParticipantInfo
			result2 error
		})
	}
	fake.listParticipantsReturnsOnCall[i] = struct {
		result1 []*livekit.ParticipantInfo
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) ListRooms() ([]*livekit.Room, error) {
	fake.listRoomsMutex.Lock()
	ret, specificReturn := fake.listRoomsReturnsOnCall[len(fake.listRoomsArgsForCall)]
	fake.listRoomsArgsForCall = append(fake.listRoomsArgsForCall, struct {
	}{})
	stub := fake.ListRoomsStub
	fakeReturns := fake.listRoomsReturns
	fake.recordInvocation("ListRooms", []interface{}{})
	fake.listRoomsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRoomStore) ListRoomsCallCount() int {
	fake.listRoomsMutex.RLock()
	defer fake.listRoomsMutex.RUnlock()
	return len(fake.listRoomsArgsForCall)
}

func (fake *FakeRoomStore) ListRoomsCalls(stub func() ([]*livekit.Room, error)) {
	fake.listRoomsMutex.Lock()
	defer fake.listRoomsMutex.Unlock()
	fake.ListRoomsStub = stub
}

func (fake *FakeRoomStore) ListRoomsReturns(result1 []*livekit.Room, result2 error) {
	fake.listRoomsMutex.Lock()
	defer fake.listRoomsMutex.Unlock()
	fake.ListRoomsStub = nil
	fake.listRoomsReturns = struct {
		result1 []*livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) ListRoomsReturnsOnCall(i int, result1 []*livekit.Room, result2 error) {
	fake.listRoomsMutex.Lock()
	defer fake.listRoomsMutex.Unlock()
	fake.ListRoomsStub = nil
	if fake.listRoomsReturnsOnCall == nil {
		fake.listRoomsReturnsOnCall = make(map[int]struct {
			result1 []*livekit.Room
			result2 error
		})
	}
	fake.listRoomsReturnsOnCall[i] = struct {
		result1 []*livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) LoadRoom(arg1 string) (*livekit.Room, error) {
	fake.loadRoomMutex.Lock()
	ret, specificReturn := fake.loadRoomReturnsOnCall[len(fake.loadRoomArgsForCall)]
	fake.loadRoomArgsForCall = append(fake.loadRoomArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.LoadRoomStub
	fakeReturns := fake.loadRoomReturns
	fake.recordInvocation("LoadRoom", []interface{}{arg1})
	fake.loadRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRoomStore) LoadRoomCallCount() int {
	fake.loadRoomMutex.RLock()
	defer fake.loadRoomMutex.RUnlock()
	return len(fake.loadRoomArgsForCall)
}

func (fake *FakeRoomStore) LoadRoomCalls(stub func(string) (*livekit.Room, error)) {
	fake.loadRoomMutex.Lock()
	defer fake.loadRoomMutex.Unlock()
	fake.LoadRoomStub = stub
}

func (fake *FakeRoomStore) LoadRoomArgsForCall(i int) string {
	fake.loadRoomMutex.RLock()
	defer fake.loadRoomMutex.RUnlock()
	argsForCall := fake.loadRoomArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomStore) LoadRoomReturns(result1 *livekit.Room, result2 error) {
	fake.loadRoomMutex.Lock()
	defer fake.loadRoomMutex.Unlock()
	fake.LoadRoomStub = nil
	fake.loadRoomReturns = struct {
		result1 *livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) LoadRoomReturnsOnCall(i int, result1 *livekit.Room, result2 error) {
	fake.loadRoomMutex.Lock()
	defer fake.loadRoomMutex.Unlock()
	fake.LoadRoomStub = nil
	if fake.loadRoomReturnsOnCall == nil {
		fake.loadRoomReturnsOnCall = make(map[int]struct {
			result1 *livekit.Room
			result2 error
		})
	}
	fake.loadRoomReturnsOnCall[i] = struct {
		result1 *livekit.Room
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) LockRoom(arg1 string, arg2 time.Duration) (string, error) {
	fake.lockRoomMutex.Lock()
	ret, specificReturn := fake.lockRoomReturnsOnCall[len(fake.lockRoomArgsForCall)]
	fake.lockRoomArgsForCall = append(fake.lockRoomArgsForCall, struct {
		arg1 string
		arg2 time.Duration
	}{arg1, arg2})
	stub := fake.LockRoomStub
	fakeReturns := fake.lockRoomReturns
	fake.recordInvocation("LockRoom", []interface{}{arg1, arg2})
	fake.lockRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeRoomStore) LockRoomCallCount() int {
	fake.lockRoomMutex.RLock()
	defer fake.lockRoomMutex.RUnlock()
	return len(fake.lockRoomArgsForCall)
}

func (fake *FakeRoomStore) LockRoomCalls(stub func(string, time.Duration) (string, error)) {
	fake.lockRoomMutex.Lock()
	defer fake.lockRoomMutex.Unlock()
	fake.LockRoomStub = stub
}

func (fake *FakeRoomStore) LockRoomArgsForCall(i int) (string, time.Duration) {
	fake.lockRoomMutex.RLock()
	defer fake.lockRoomMutex.RUnlock()
	argsForCall := fake.lockRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRoomStore) LockRoomReturns(result1 string, result2 error) {
	fake.lockRoomMutex.Lock()
	defer fake.lockRoomMutex.Unlock()
	fake.LockRoomStub = nil
	fake.lockRoomReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) LockRoomReturnsOnCall(i int, result1 string, result2 error) {
	fake.lockRoomMutex.Lock()
	defer fake.lockRoomMutex.Unlock()
	fake.LockRoomStub = nil
	if fake.lockRoomReturnsOnCall == nil {
		fake.lockRoomReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.lockRoomReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRoomStore) StoreParticipant(arg1 string, arg2 *livekit.ParticipantInfo) error {
	fake.persistParticipantMutex.Lock()
	ret, specificReturn := fake.persistParticipantReturnsOnCall[len(fake.persistParticipantArgsForCall)]
	fake.persistParticipantArgsForCall = append(fake.persistParticipantArgsForCall, struct {
		arg1 string
		arg2 *livekit.ParticipantInfo
	}{arg1, arg2})
	stub := fake.PersistParticipantStub
	fakeReturns := fake.persistParticipantReturns
	fake.recordInvocation("StoreParticipant", []interface{}{arg1, arg2})
	fake.persistParticipantMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRoomStore) PersistParticipantCallCount() int {
	fake.persistParticipantMutex.RLock()
	defer fake.persistParticipantMutex.RUnlock()
	return len(fake.persistParticipantArgsForCall)
}

func (fake *FakeRoomStore) PersistParticipantCalls(stub func(string, *livekit.ParticipantInfo) error) {
	fake.persistParticipantMutex.Lock()
	defer fake.persistParticipantMutex.Unlock()
	fake.PersistParticipantStub = stub
}

func (fake *FakeRoomStore) PersistParticipantArgsForCall(i int) (string, *livekit.ParticipantInfo) {
	fake.persistParticipantMutex.RLock()
	defer fake.persistParticipantMutex.RUnlock()
	argsForCall := fake.persistParticipantArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRoomStore) PersistParticipantReturns(result1 error) {
	fake.persistParticipantMutex.Lock()
	defer fake.persistParticipantMutex.Unlock()
	fake.PersistParticipantStub = nil
	fake.persistParticipantReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) PersistParticipantReturnsOnCall(i int, result1 error) {
	fake.persistParticipantMutex.Lock()
	defer fake.persistParticipantMutex.Unlock()
	fake.PersistParticipantStub = nil
	if fake.persistParticipantReturnsOnCall == nil {
		fake.persistParticipantReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.persistParticipantReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) StoreRoom(arg1 *livekit.Room) error {
	fake.storeRoomMutex.Lock()
	ret, specificReturn := fake.storeRoomReturnsOnCall[len(fake.storeRoomArgsForCall)]
	fake.storeRoomArgsForCall = append(fake.storeRoomArgsForCall, struct {
		arg1 *livekit.Room
	}{arg1})
	stub := fake.StoreRoomStub
	fakeReturns := fake.storeRoomReturns
	fake.recordInvocation("StoreRoom", []interface{}{arg1})
	fake.storeRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRoomStore) StoreRoomCallCount() int {
	fake.storeRoomMutex.RLock()
	defer fake.storeRoomMutex.RUnlock()
	return len(fake.storeRoomArgsForCall)
}

func (fake *FakeRoomStore) StoreRoomCalls(stub func(*livekit.Room) error) {
	fake.storeRoomMutex.Lock()
	defer fake.storeRoomMutex.Unlock()
	fake.StoreRoomStub = stub
}

func (fake *FakeRoomStore) StoreRoomArgsForCall(i int) *livekit.Room {
	fake.storeRoomMutex.RLock()
	defer fake.storeRoomMutex.RUnlock()
	argsForCall := fake.storeRoomArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeRoomStore) StoreRoomReturns(result1 error) {
	fake.storeRoomMutex.Lock()
	defer fake.storeRoomMutex.Unlock()
	fake.StoreRoomStub = nil
	fake.storeRoomReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) StoreRoomReturnsOnCall(i int, result1 error) {
	fake.storeRoomMutex.Lock()
	defer fake.storeRoomMutex.Unlock()
	fake.StoreRoomStub = nil
	if fake.storeRoomReturnsOnCall == nil {
		fake.storeRoomReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeRoomReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) UnlockRoom(arg1 string, arg2 string) error {
	fake.unlockRoomMutex.Lock()
	ret, specificReturn := fake.unlockRoomReturnsOnCall[len(fake.unlockRoomArgsForCall)]
	fake.unlockRoomArgsForCall = append(fake.unlockRoomArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.UnlockRoomStub
	fakeReturns := fake.unlockRoomReturns
	fake.recordInvocation("UnlockRoom", []interface{}{arg1, arg2})
	fake.unlockRoomMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeRoomStore) UnlockRoomCallCount() int {
	fake.unlockRoomMutex.RLock()
	defer fake.unlockRoomMutex.RUnlock()
	return len(fake.unlockRoomArgsForCall)
}

func (fake *FakeRoomStore) UnlockRoomCalls(stub func(string, string) error) {
	fake.unlockRoomMutex.Lock()
	defer fake.unlockRoomMutex.Unlock()
	fake.UnlockRoomStub = stub
}

func (fake *FakeRoomStore) UnlockRoomArgsForCall(i int) (string, string) {
	fake.unlockRoomMutex.RLock()
	defer fake.unlockRoomMutex.RUnlock()
	argsForCall := fake.unlockRoomArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeRoomStore) UnlockRoomReturns(result1 error) {
	fake.unlockRoomMutex.Lock()
	defer fake.unlockRoomMutex.Unlock()
	fake.UnlockRoomStub = nil
	fake.unlockRoomReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) UnlockRoomReturnsOnCall(i int, result1 error) {
	fake.unlockRoomMutex.Lock()
	defer fake.unlockRoomMutex.Unlock()
	fake.UnlockRoomStub = nil
	if fake.unlockRoomReturnsOnCall == nil {
		fake.unlockRoomReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unlockRoomReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRoomStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.deleteParticipantMutex.RLock()
	defer fake.deleteParticipantMutex.RUnlock()
	fake.deleteRoomMutex.RLock()
	defer fake.deleteRoomMutex.RUnlock()
	fake.getParticipantMutex.RLock()
	defer fake.getParticipantMutex.RUnlock()
	fake.listParticipantsMutex.RLock()
	defer fake.listParticipantsMutex.RUnlock()
	fake.listRoomsMutex.RLock()
	defer fake.listRoomsMutex.RUnlock()
	fake.loadRoomMutex.RLock()
	defer fake.loadRoomMutex.RUnlock()
	fake.lockRoomMutex.RLock()
	defer fake.lockRoomMutex.RUnlock()
	fake.persistParticipantMutex.RLock()
	defer fake.persistParticipantMutex.RUnlock()
	fake.storeRoomMutex.RLock()
	defer fake.storeRoomMutex.RUnlock()
	fake.unlockRoomMutex.RLock()
	defer fake.unlockRoomMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRoomStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.RoomStore = new(FakeRoomStore)
