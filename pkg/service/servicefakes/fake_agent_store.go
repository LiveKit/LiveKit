// Code generated by counterfeiter. DO NOT EDIT.
package servicefakes

import (
	"context"
	"sync"

	"github.com/livekit/livekit-server/pkg/service"
	"github.com/livekit/protocol/livekit"
)

type FakeAgentStore struct {
	ListDispatchesStub        func(context.Context, livekit.RoomName) ([]*livekit.AgentDispatch, error)
	listDispatchesMutex       sync.RWMutex
	listDispatchesArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.RoomName
	}
	listDispatchesReturns struct {
		result1 []*livekit.AgentDispatch
		result2 error
	}
	listDispatchesReturnsOnCall map[int]struct {
		result1 []*livekit.AgentDispatch
		result2 error
	}
	ListJobsStub        func(context.Context, livekit.RoomName) ([]*livekit.Job, error)
	listJobsMutex       sync.RWMutex
	listJobsArgsForCall []struct {
		arg1 context.Context
		arg2 livekit.RoomName
	}
	listJobsReturns struct {
		result1 []*livekit.Job
		result2 error
	}
	listJobsReturnsOnCall map[int]struct {
		result1 []*livekit.Job
		result2 error
	}
	StoreDispatchStub        func(context.Context, *livekit.AgentDispatch) error
	storeDispatchMutex       sync.RWMutex
	storeDispatchArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.AgentDispatch
	}
	storeDispatchReturns struct {
		result1 error
	}
	storeDispatchReturnsOnCall map[int]struct {
		result1 error
	}
	StoreJobStub        func(context.Context, *livekit.Job) error
	storeJobMutex       sync.RWMutex
	storeJobArgsForCall []struct {
		arg1 context.Context
		arg2 *livekit.Job
	}
	storeJobReturns struct {
		result1 error
	}
	storeJobReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAgentStore) ListDispatches(arg1 context.Context, arg2 livekit.RoomName) ([]*livekit.AgentDispatch, error) {
	fake.listDispatchesMutex.Lock()
	ret, specificReturn := fake.listDispatchesReturnsOnCall[len(fake.listDispatchesArgsForCall)]
	fake.listDispatchesArgsForCall = append(fake.listDispatchesArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.RoomName
	}{arg1, arg2})
	stub := fake.ListDispatchesStub
	fakeReturns := fake.listDispatchesReturns
	fake.recordInvocation("ListDispatches", []interface{}{arg1, arg2})
	fake.listDispatchesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAgentStore) ListDispatchesCallCount() int {
	fake.listDispatchesMutex.RLock()
	defer fake.listDispatchesMutex.RUnlock()
	return len(fake.listDispatchesArgsForCall)
}

func (fake *FakeAgentStore) ListDispatchesCalls(stub func(context.Context, livekit.RoomName) ([]*livekit.AgentDispatch, error)) {
	fake.listDispatchesMutex.Lock()
	defer fake.listDispatchesMutex.Unlock()
	fake.ListDispatchesStub = stub
}

func (fake *FakeAgentStore) ListDispatchesArgsForCall(i int) (context.Context, livekit.RoomName) {
	fake.listDispatchesMutex.RLock()
	defer fake.listDispatchesMutex.RUnlock()
	argsForCall := fake.listDispatchesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAgentStore) ListDispatchesReturns(result1 []*livekit.AgentDispatch, result2 error) {
	fake.listDispatchesMutex.Lock()
	defer fake.listDispatchesMutex.Unlock()
	fake.ListDispatchesStub = nil
	fake.listDispatchesReturns = struct {
		result1 []*livekit.AgentDispatch
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentStore) ListDispatchesReturnsOnCall(i int, result1 []*livekit.AgentDispatch, result2 error) {
	fake.listDispatchesMutex.Lock()
	defer fake.listDispatchesMutex.Unlock()
	fake.ListDispatchesStub = nil
	if fake.listDispatchesReturnsOnCall == nil {
		fake.listDispatchesReturnsOnCall = make(map[int]struct {
			result1 []*livekit.AgentDispatch
			result2 error
		})
	}
	fake.listDispatchesReturnsOnCall[i] = struct {
		result1 []*livekit.AgentDispatch
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentStore) ListJobs(arg1 context.Context, arg2 livekit.RoomName) ([]*livekit.Job, error) {
	fake.listJobsMutex.Lock()
	ret, specificReturn := fake.listJobsReturnsOnCall[len(fake.listJobsArgsForCall)]
	fake.listJobsArgsForCall = append(fake.listJobsArgsForCall, struct {
		arg1 context.Context
		arg2 livekit.RoomName
	}{arg1, arg2})
	stub := fake.ListJobsStub
	fakeReturns := fake.listJobsReturns
	fake.recordInvocation("ListJobs", []interface{}{arg1, arg2})
	fake.listJobsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAgentStore) ListJobsCallCount() int {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	return len(fake.listJobsArgsForCall)
}

func (fake *FakeAgentStore) ListJobsCalls(stub func(context.Context, livekit.RoomName) ([]*livekit.Job, error)) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = stub
}

func (fake *FakeAgentStore) ListJobsArgsForCall(i int) (context.Context, livekit.RoomName) {
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	argsForCall := fake.listJobsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAgentStore) ListJobsReturns(result1 []*livekit.Job, result2 error) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	fake.listJobsReturns = struct {
		result1 []*livekit.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentStore) ListJobsReturnsOnCall(i int, result1 []*livekit.Job, result2 error) {
	fake.listJobsMutex.Lock()
	defer fake.listJobsMutex.Unlock()
	fake.ListJobsStub = nil
	if fake.listJobsReturnsOnCall == nil {
		fake.listJobsReturnsOnCall = make(map[int]struct {
			result1 []*livekit.Job
			result2 error
		})
	}
	fake.listJobsReturnsOnCall[i] = struct {
		result1 []*livekit.Job
		result2 error
	}{result1, result2}
}

func (fake *FakeAgentStore) StoreDispatch(arg1 context.Context, arg2 *livekit.AgentDispatch) error {
	fake.storeDispatchMutex.Lock()
	ret, specificReturn := fake.storeDispatchReturnsOnCall[len(fake.storeDispatchArgsForCall)]
	fake.storeDispatchArgsForCall = append(fake.storeDispatchArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.AgentDispatch
	}{arg1, arg2})
	stub := fake.StoreDispatchStub
	fakeReturns := fake.storeDispatchReturns
	fake.recordInvocation("StoreDispatch", []interface{}{arg1, arg2})
	fake.storeDispatchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAgentStore) StoreDispatchCallCount() int {
	fake.storeDispatchMutex.RLock()
	defer fake.storeDispatchMutex.RUnlock()
	return len(fake.storeDispatchArgsForCall)
}

func (fake *FakeAgentStore) StoreDispatchCalls(stub func(context.Context, *livekit.AgentDispatch) error) {
	fake.storeDispatchMutex.Lock()
	defer fake.storeDispatchMutex.Unlock()
	fake.StoreDispatchStub = stub
}

func (fake *FakeAgentStore) StoreDispatchArgsForCall(i int) (context.Context, *livekit.AgentDispatch) {
	fake.storeDispatchMutex.RLock()
	defer fake.storeDispatchMutex.RUnlock()
	argsForCall := fake.storeDispatchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAgentStore) StoreDispatchReturns(result1 error) {
	fake.storeDispatchMutex.Lock()
	defer fake.storeDispatchMutex.Unlock()
	fake.StoreDispatchStub = nil
	fake.storeDispatchReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAgentStore) StoreDispatchReturnsOnCall(i int, result1 error) {
	fake.storeDispatchMutex.Lock()
	defer fake.storeDispatchMutex.Unlock()
	fake.StoreDispatchStub = nil
	if fake.storeDispatchReturnsOnCall == nil {
		fake.storeDispatchReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeDispatchReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAgentStore) StoreJob(arg1 context.Context, arg2 *livekit.Job) error {
	fake.storeJobMutex.Lock()
	ret, specificReturn := fake.storeJobReturnsOnCall[len(fake.storeJobArgsForCall)]
	fake.storeJobArgsForCall = append(fake.storeJobArgsForCall, struct {
		arg1 context.Context
		arg2 *livekit.Job
	}{arg1, arg2})
	stub := fake.StoreJobStub
	fakeReturns := fake.storeJobReturns
	fake.recordInvocation("StoreJob", []interface{}{arg1, arg2})
	fake.storeJobMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeAgentStore) StoreJobCallCount() int {
	fake.storeJobMutex.RLock()
	defer fake.storeJobMutex.RUnlock()
	return len(fake.storeJobArgsForCall)
}

func (fake *FakeAgentStore) StoreJobCalls(stub func(context.Context, *livekit.Job) error) {
	fake.storeJobMutex.Lock()
	defer fake.storeJobMutex.Unlock()
	fake.StoreJobStub = stub
}

func (fake *FakeAgentStore) StoreJobArgsForCall(i int) (context.Context, *livekit.Job) {
	fake.storeJobMutex.RLock()
	defer fake.storeJobMutex.RUnlock()
	argsForCall := fake.storeJobArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAgentStore) StoreJobReturns(result1 error) {
	fake.storeJobMutex.Lock()
	defer fake.storeJobMutex.Unlock()
	fake.StoreJobStub = nil
	fake.storeJobReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAgentStore) StoreJobReturnsOnCall(i int, result1 error) {
	fake.storeJobMutex.Lock()
	defer fake.storeJobMutex.Unlock()
	fake.StoreJobStub = nil
	if fake.storeJobReturnsOnCall == nil {
		fake.storeJobReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.storeJobReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAgentStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.listDispatchesMutex.RLock()
	defer fake.listDispatchesMutex.RUnlock()
	fake.listJobsMutex.RLock()
	defer fake.listJobsMutex.RUnlock()
	fake.storeDispatchMutex.RLock()
	defer fake.storeDispatchMutex.RUnlock()
	fake.storeJobMutex.RLock()
	defer fake.storeJobMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAgentStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ service.AgentStore = new(FakeAgentStore)
